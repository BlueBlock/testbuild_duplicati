<?xml version="1.0"?>
<doc>
    <assembly>
        <name>CoCoL</name>
    </assembly>
    <members>
        <member name="T:CoCoL.ChannelManager">
            <summary>
            Channel manager, responsible for creating named and unnamed channels
            </summary>
        </member>
        <member name="M:CoCoL.ChannelManager.GetChannel``1(System.String,System.Int32,CoCoL.ChannelScope,System.Int32,System.Int32,CoCoL.QueueOverflowStrategy,CoCoL.QueueOverflowStrategy,System.Boolean,System.Int32,System.Int32)">
            <summary>
            Gets or creates a named channel.
            </summary>
            <returns>The named channel.</returns>
            <param name="name">The name of the channel to find.</param>
            <param name="buffersize">The number of buffers in the channel.</param>
            <param name="scope">The scope to create a named channel in, defaults to null which means the current scope</param>
            <param name="maxPendingReaders">The maximum number of pending readers. A negative value indicates infinite</param>
            <param name="maxPendingWriters">The maximum number of pending writers. A negative value indicates infinite</param>
            <param name="pendingReadersOverflowStrategy">The strategy for dealing with overflow for read requests</param>
            <param name="pendingWritersOverflowStrategy">The strategy for dealing with overflow for write requests</param>
            <param name="broadcast"><c>True</c> will create the channel as a broadcast channel, the default <c>false</c> will create a normal channel</param>
            <param name="initialBroadcastBarrier">The number of readers required on the channel before sending the first broadcast, can only be used with broadcast channels</param>
            <param name="broadcastMinimum">The minimum number of readers required on the channel, before a broadcast can be performed, can only be used with broadcast channels</param>
            <typeparam name="T">The channel type.</typeparam>
        </member>
        <member name="M:CoCoL.ChannelManager.GetChannel``1(CoCoL.ChannelNameAttribute,CoCoL.ChannelScope)">
            <summary>
            Gets or creates a named channel.
            </summary>
            <returns>The named channel.</returns>
            <param name="attr">The attribute describing the channel.</param>
            <param name="scope">The scope to create a named channel in, defaults to null which means the current scope</param>
            <typeparam name="T">The channel type.</typeparam>
        </member>
        <member name="M:CoCoL.ChannelManager.GetChannel``1(CoCoL.ChannelMarkerWrapper{``0})">
            <summary>
            Gets or creates a named channel from a marker setup
            </summary>
            <returns>The named channel.</returns>
            <param name="marker">The channel marker instance that describes the channel.</param>
            <typeparam name="T">The channel type.</typeparam>
        </member>
        <member name="M:CoCoL.ChannelManager.GetChannel``1(CoCoL.IWriteChannel{``0})">
            <summary>
            Gets a write channel from a marker interface.
            </summary>
            <returns>The requested channel.</returns>
            <param name="channel">The marker interface, or a real channel instance.</param>
            <typeparam name="T">The channel type.</typeparam>
        </member>
        <member name="M:CoCoL.ChannelManager.GetChannel``1(CoCoL.IReadChannel{``0})">
            <summary>
            Gets a read channel from a marker interface.
            </summary>
            <returns>The requested channel.</returns>
            <param name="channel">The marker interface, or a real channel instance.</param>
            <typeparam name="T">The channel type.</typeparam>
        </member>
        <member name="M:CoCoL.ChannelManager.CreateChannel``1(System.String,System.Int32,CoCoL.ChannelScope,System.Int32,System.Int32,CoCoL.QueueOverflowStrategy,CoCoL.QueueOverflowStrategy,System.Boolean,System.Int32,System.Int32)">
            <summary>
            Creates a channel, possibly unnamed.
            If a channel name is provided, the channel is created in the supplied scope.
            If a channel with the given name is already found in the supplied scope, the named channel is returned.
            </summary>
            <returns>The channel.</returns>
            <param name="name">The name of the channel, or null.</param>
            <param name="buffersize">The number of buffers in the channel.</param>
            <param name="scope">The scope to create a named channel in, defaults to null which means the current scope</param>
            <param name="maxPendingReaders">The maximum number of pending readers. A negative value indicates infinite</param>
            <param name="maxPendingWriters">The maximum number of pending writers. A negative value indicates infinite</param>
            <param name="pendingReadersOverflowStrategy">The strategy for dealing with overflow for read requests</param>
            <param name="pendingWritersOverflowStrategy">The strategy for dealing with overflow for write requests</param>
            <param name="broadcast"><c>True</c> will create the channel as a broadcast channel, the default <c>false</c> will create a normal channel</param>
            <param name="initialBroadcastBarrier">The number of readers required on the channel before sending the first broadcast, can only be used with broadcast channels</param>
            <param name="broadcastMinimum">The minimum number of readers required on the channel, before a broadcast can be performed, can only be used with broadcast channels</param>
            <typeparam name="T">The channel type.</typeparam>
        </member>
        <member name="M:CoCoL.ChannelManager.CreateChannel``1(CoCoL.ChannelNameAttribute,CoCoL.ChannelScope)">
            <summary>
            Creates a channel, possibly unnamed.
            If a channel name is provided, the channel is created in the supplied scope.
            If a channel with the given name is already found in the supplied scope, the named channel is returned.
            </summary>
            <returns>The named channel.</returns>
            <param name="attr">The attribute describing the channel.</param>
            <param name="scope">The scope to create a named channel in, defaults to null which means the current scope</param>
            <typeparam name="T">The channel type.</typeparam>
        </member>
        <member name="M:CoCoL.ChannelManager.CreateChannelForScope``1(CoCoL.ChannelNameAttribute)">
            <summary>
            Creates a channel for use in a scope
            </summary>
            <returns>The channel.</returns>
            <param name="attribute">The attribute describing the channel.</param>
            <typeparam name="T">The channel type.</typeparam>
        </member>
        <member name="T:CoCoL.Channel`1">
            <summary>
            A channel that uses continuation callbacks
            </summary>
        </member>
        <member name="F:CoCoL.Channel`1.MIN_QUEUE_CLEANUP_THRESHOLD">
            <summary>
            The minium value for the cleanup threshold
            </summary>
        </member>
        <member name="T:CoCoL.Channel`1.IEntry">
            <summary>
            Interface for an offer
            </summary>
        </member>
        <member name="P:CoCoL.Channel`1.IEntry.Offer">
            <summary>
            The two-phase offer instance
            </summary>
            <value>The offer.</value>
        </member>
        <member name="M:CoCoL.Channel`1.IEntry.TrySetCancelled">
            <summary>
            Convenience method for setting the offer cancelled
            </summary>
        </member>
        <member name="T:CoCoL.Channel`1.ReaderEntry">
            <summary>
            Structure for keeping a read request
            </summary>
        </member>
        <member name="F:CoCoL.Channel`1.ReaderEntry.Offer">
            <summary>
            The offer handler for the request
            </summary>
        </member>
        <member name="F:CoCoL.Channel`1.ReaderEntry.Source">
            <summary>
            The callback method for reporting progress
            </summary>
        </member>
        <member name="F:CoCoL.Channel`1.ReaderEntry.Expires">
            <summary>
            The timeout value
            </summary>
        </member>
        <member name="M:CoCoL.Channel`1.ReaderEntry.#ctor(CoCoL.ITwoPhaseOffer,System.Threading.Tasks.TaskCompletionSource{`0},System.DateTime)">
            <summary>
            Initializes a new instance of the <see cref="T:CoCoL.Channel`1.ReaderEntry"/> struct.
            </summary>
            <param name="offer">The offer handler</param>
            <param name="callback">The callback method for reporting progress.</param>
            <param name="expires">The timeout value.</param>
        </member>
        <member name="P:CoCoL.Channel`1.ReaderEntry.CoCoL#Channel{T}#IEntry#Offer">
            <summary>
            The offer handler for the request
            </summary>
        </member>
        <member name="M:CoCoL.Channel`1.ReaderEntry.CoCoL#Channel{T}#IEntry#TrySetCancelled">
            <summary>
            Tries to set the source to Cancelled
            </summary>
        </member>
        <member name="T:CoCoL.Channel`1.WriterEntry">
            <summary>
            Structure for keeping a write request
            </summary>
        </member>
        <member name="F:CoCoL.Channel`1.WriterEntry.Offer">
            <summary>
            The offer handler for the request
            </summary>
        </member>
        <member name="F:CoCoL.Channel`1.WriterEntry.Source">
            <summary>
            The callback method for reporting progress
            </summary>
        </member>
        <member name="F:CoCoL.Channel`1.WriterEntry.Expires">
            <summary>
            The timeout value
            </summary>
        </member>
        <member name="F:CoCoL.Channel`1.WriterEntry.Value">
            <summary>
            The value being written
            </summary>
        </member>
        <member name="M:CoCoL.Channel`1.WriterEntry.#ctor(CoCoL.ITwoPhaseOffer,System.Threading.Tasks.TaskCompletionSource{System.Boolean},System.DateTime,`0)">
            <summary>
            Initializes a new instance of the <see cref="T:CoCoL.Channel`1.WriterEntry"/> struct.
            </summary>
            <param name="offer">The offer handler</param>
            <param name="callback">The callback method for reporting progress.</param>
            <param name="expires">The timeout value.</param>
            <param name="value">The value being written.</param>
        </member>
        <member name="P:CoCoL.Channel`1.WriterEntry.CoCoL#Channel{T}#IEntry#Offer">
            <summary>
            The offer handler for the request
            </summary>
        </member>
        <member name="M:CoCoL.Channel`1.WriterEntry.CoCoL#Channel{T}#IEntry#TrySetCancelled">
            <summary>
            Tries to set the source to Cancelled
            </summary>
        </member>
        <member name="F:CoCoL.Channel`1.m_readerQueue">
            <summary>
            The queue with pending readers
            </summary>
        </member>
        <member name="F:CoCoL.Channel`1.m_writerQueue">
            <summary>
            The queue with pending writers
            </summary>
        </member>
        <member name="F:CoCoL.Channel`1.m_bufferSize">
            <summary>
            The maximal size of the queue
            </summary>
        </member>
        <member name="F:CoCoL.Channel`1.m_asynclock">
            <summary>
            The lock object protecting access to the queues
            </summary>
        </member>
        <member name="P:CoCoL.Channel`1.Name">
            <summary>
            Gets or sets the name of the channel
            </summary>
            <value>The name.</value>
        </member>
        <member name="P:CoCoL.Channel`1.IsRetiredAsync">
            <summary>
            Gets a value indicating whether this instance is retired.
            </summary>
            <value><c>true</c> if this instance is retired; otherwise, <c>false</c>.</value>
        </member>
        <member name="F:CoCoL.Channel`1.m_isRetired">
            <summary>
            Gets a value indicating whether this instance is retired.
            </summary>
        </member>
        <member name="F:CoCoL.Channel`1.m_retireCount">
            <summary>
            The number of messages to process before marking the channel as retired
            </summary>
        </member>
        <member name="F:CoCoL.Channel`1.m_joinedReaderCount">
            <summary>
            The number of reader processes having joined the channel
            </summary>
        </member>
        <member name="F:CoCoL.Channel`1.m_joinedWriterCount">
            <summary>
            The number of writer processes having joined the channel
            </summary>
        </member>
        <member name="F:CoCoL.Channel`1.m_writerQueueCleanup">
            <summary>
            The threshold for performing writer queue cleanup
            </summary>
        </member>
        <member name="F:CoCoL.Channel`1.m_readerQueueCleanup">
            <summary>
            The threshold for performing reader queue cleanup
            </summary>
        </member>
        <member name="F:CoCoL.Channel`1.m_maxPendingReaders">
            <summary>
            The maximum number of pending readers to allow
            </summary>
        </member>
        <member name="F:CoCoL.Channel`1.m_pendingReadersOverflowStrategy">
            <summary>
            The strategy for selecting pending readers to discard on overflow
            </summary>
        </member>
        <member name="F:CoCoL.Channel`1.m_maxPendingWriters">
            <summary>
            The maximum number of pending writers to allow
            </summary>
        </member>
        <member name="F:CoCoL.Channel`1.m_pendingWritersOverflowStrategy">
            <summary>
            The strategy for selecting pending writers to discard on overflow
            </summary>
        </member>
        <member name="M:CoCoL.Channel`1.#ctor(CoCoL.ChannelNameAttribute)">
            <summary>
            Initializes a new instance of the <see cref="T:CoCoL.Channel`1"/> class.
            </summary>
            <param name="attribute">The attribute describing the channel</param>
        </member>
        <member name="M:CoCoL.Channel`1.GetIsRetiredAsync">
            <summary>
            Helper method for accessor to get the retired state
            </summary>
            <returns>The is retired async.</returns>
        </member>
        <member name="M:CoCoL.Channel`1.Offer(CoCoL.Channel{`0}.WriterEntry)">
            <summary>
            Offers a transaction to the write end
            </summary>
            <param name="wr">The writer entry.</param>
        </member>
        <member name="M:CoCoL.Channel`1.Offer(CoCoL.Channel{`0}.ReaderEntry)">
            <summary>
            Offersa transaction to the read end
            </summary>
            <param name="rd">The reader entry.</param>
        </member>
        <member name="M:CoCoL.Channel`1.MatchReadersAndWriters(System.Boolean,System.Threading.Tasks.Task)">
            <summary>
            Method that examines the queues and matches readers with writers
            </summary>
            <returns>An awaitable that signals if the caller has been accepted or rejected.</returns>
            <param name="asReader"><c>True</c> if the caller method is a reader, <c>false</c> otherwise.</param>
            <param name="caller">The caller task.</param>
        </member>
        <member name="M:CoCoL.Channel`1.ReadAsync(CoCoL.ITwoPhaseOffer)">
            <summary>
            Registers a desire to read from the channel
            </summary>
            <param name="offer">A callback method for offering an item, use null to unconditionally accept</param>
        </member>
        <member name="M:CoCoL.Channel`1.ReadAsync(System.TimeSpan,CoCoL.ITwoPhaseOffer)">
            <summary>
            Registers a desire to read from the channel
            </summary>
            <param name="offer">A callback method for offering an item, use null to unconditionally accept</param>
            <param name="timeout">The time to wait for the operation, use zero to return a timeout immediately if no items can be read. Use a negative span to wait forever.</param>
        </member>
        <member name="M:CoCoL.Channel`1.WriteAsync(`0,CoCoL.ITwoPhaseOffer)">
            <summary>
            Registers a desire to write to the channel
            </summary>
            <param name="offer">A callback method for offering an item, use null to unconditionally accept</param>
            <param name="value">The value to write to the channel.</param>
        </member>
        <member name="M:CoCoL.Channel`1.WriteAsync(`0,System.TimeSpan,CoCoL.ITwoPhaseOffer)">
            <summary>
            Registers a desire to write to the channel
            </summary>
            <param name="offer">A callback method for offering an item, use null to unconditionally accept</param>
            <param name="value">The value to write to the channel.</param>
            <param name="timeout">The time to wait for the operation, use zero to return a timeout immediately if no items can be read. Use a negative span to wait forever.</param>
        </member>
        <member name="M:CoCoL.Channel`1.PerformQueueCleanupAsync``1(System.Collections.Generic.List{``0},System.Boolean,System.Int32)">
            <summary>
            Purges items in the queue that are no longer active
            </summary>
            <param name="queue">The queue to remove from.</param>
            <param name="queueCleanup">The threshold parameter.</param>
            <param name="isLocked"><c>True</c> if we are already holding the lock, <c>false</c> otherwise</param>
            <typeparam name="Tx">The type of list data.</typeparam>
        </member>
        <member name="M:CoCoL.Channel`1.ProcessWriteQueueBufferAfterReadAsync(System.Boolean)">
            <summary>
            Helper method for dequeueing write requests after space has been allocated in the writer queue
            </summary>
            <param name="isLocked"><c>True</c> if we are already holding the lock, <c>false</c> otherwise</param>
        </member>
        <member name="M:CoCoL.Channel`1.RetireAsync">
            <summary>
            Stops this channel from processing messages
            </summary>
        </member>
        <member name="M:CoCoL.Channel`1.RetireAsync(System.Boolean)">
            <summary>
            Stops this channel from processing messages
            </summary>
            <param name="immediate">Retires the channel without processing the queue, which may cause lost messages</param>
        </member>
        <member name="M:CoCoL.Channel`1.RetireAsync(System.Boolean,System.Boolean)">
            <summary>
            Stops this channel from processing messages
            </summary>
            <param name="immediate">Retires the channel without processing the queue, which may cause lost messages</param>
            <param name="isLocked"><c>True</c> if we are already holding the lock, <c>false</c> otherwise</param>
        </member>
        <member name="M:CoCoL.Channel`1.JoinAsync(System.Boolean)">
            <summary>
            Join the channel
            </summary>
            <param name="asReader"><c>true</c> if joining as a reader, <c>false</c> otherwise</param>
        </member>
        <member name="M:CoCoL.Channel`1.LeaveAsync(System.Boolean)">
            <summary>
            Leave the channel.
            </summary>
            <param name="asReader"><c>true</c> if leaving as a reader, <c>false</c> otherwise</param>
        </member>
        <member name="M:CoCoL.Channel`1.EmptyQueueIfRetiredAsync(System.Boolean)">
            <summary>
            Empties the queue if the channel is retired.
            </summary>
            <param name="isLocked"><c>True</c> if we are already holding the lock, <c>false</c> otherwise</param>
        </member>
        <member name="M:CoCoL.Channel`1.ExpireItemsAsync">
            <summary>
            Callback method used to signal timeout on expired items
            </summary>
        </member>
        <member name="T:CoCoL.ChannelExtensions">
            <summary>
            This static class provides various extension methods for
            simplifying the use of channels other than async
            </summary>
        </member>
        <member name="F:CoCoL.ChannelExtensions.IsRunningMono">
            <summary>
            Single-shot variable that is set if we are running under the Mono runtime
            </summary>
        </member>
        <member name="M:CoCoL.ChannelExtensions.WaitForTask``1(System.Threading.Tasks.Task{``0})">
            <summary>
            Blocking wait for a task, equivalent to calling Task.Wait(),
            but works around a race in Mono that causes Wait() to hang
            </summary>
            <param name="task">The task to wait for</param>
            <returns>The task</returns>
            <typeparam name="T">The task data type.</typeparam>
        </member>
        <member name="M:CoCoL.ChannelExtensions.WaitForTask(System.Threading.Tasks.Task)">
            <summary>
            Blocking wait for a task, equivalent to calling Task.Wait(),
            but works around a race in Mono that causes Wait() to hang
            </summary>
            <param name="task">The task to wait for</param>
            <returns>The task</returns>
        </member>
        <member name="M:CoCoL.ChannelExtensions.WaitForTaskOrThrow(System.Threading.Tasks.Task)">
            <summary>
            Blocking wait for a task, equivalent to calling Task.Wait(),
            but works around a race in Mono that causes Wait() to hang.
            If an error occurs, an exception is thrown
            </summary>
            <param name="task">The task to wait for</param>
            <returns>The task</returns>
        </member>
        <member name="M:CoCoL.ChannelExtensions.FireAndForget(System.Threading.Tasks.Task)">
            <summary>
            Leaves the task un-awaited, supressing warnings if the task is not awaited
            </summary>
            <param name="task">he task to suppress.</param>
        </member>
        <member name="M:CoCoL.ChannelExtensions.WhenAnyNonCancelled(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task},System.Threading.Tasks.TaskCompletionSource{System.Threading.Tasks.Task})">
            <summary>
            Helper method that implements WhenAny with the NotOnCancelled flag
            </summary>
            <returns>A task that completes when a NonCancelled task returns, or no more tasks are available</returns>
            <param name="items">Items.</param>
            <param name="source">The task completion source to signal</param>
        </member>
        <member name="M:CoCoL.ChannelExtensions.WriteNoWait``1(CoCoL.IWriteChannel{``0},``0)">
            <summary>
            Write to the channel in a blocking manner
            </summary>
            <param name="value">The value to write into the channel</param>
            <param name="self">The channel to read from</param>
            <typeparam name="T">The channel data type parameter.</typeparam>
        </member>
        <member name="M:CoCoL.ChannelExtensions.WriteNoWait``1(CoCoL.IWriteChannel{``0},``0,System.TimeSpan)">
            <summary>
            Write to the channel in a blocking manner
            </summary>
            <param name="value">The value to write into the channel</param>
            <param name="self">The channel to read from</param>
            <param name="timeout">The maximum time to wait for an available slot</param>
            <typeparam name="T">The channel data type parameter.</typeparam>
        </member>
        <member name="M:CoCoL.ChannelExtensions.TryWriteAsync``1(CoCoL.IWriteChannel{``0},``0)">
            <summary>
            Write to the channel in a probing and asynchronous manner
            </summary>
            <param name="value">The value to write into the channel</param>
            <param name="self">The channel to read from</param>
            <typeparam name="T">The channel data type parameter.</typeparam>
            <returns>True if the write succeeded, false otherwise</returns>
        </member>
        <member name="M:CoCoL.ChannelExtensions.TryReadAsync``1(CoCoL.IReadChannel{``0})">
            <summary>
            Reads the channel in a probing and asynchronous manner
            </summary>
            <param name="self">The channel to read from</param>
            <typeparam name="T">The channel data type parameter.</typeparam>
            <returns>True if the read succeeded, false otherwise</returns>
        </member>
        <member name="M:CoCoL.ChannelExtensions.Read``1(CoCoL.IReadChannel{``0})">
            <summary>
            Read from the channel in a blocking manner
            </summary>
            <param name="self">The channel to read from</param>
            <typeparam name="T">The channel data type parameter.</typeparam>
            <returns>The value read from the channel</returns>
        </member>
        <member name="M:CoCoL.ChannelExtensions.Read``1(CoCoL.IReadChannel{``0},System.TimeSpan)">
            <summary>
            Read from the channel in a blocking manner
            </summary>
            <param name="self">The channel to read from</param>
            <param name="timeout">The maximum time to wait for a value</param>
            <returns>>The value read from the channel</returns>
            <typeparam name="T">The channel data type parameter.</typeparam>
        </member>
        <member name="M:CoCoL.ChannelExtensions.TryRead``1(CoCoL.IReadChannel{``0},``0@)">
            <summary>
            Read from the channel in a probing manner
            </summary>
            <param name="self">The channel to read from</param>
            <param name="result">The read result</param>
            <typeparam name="T">The channel data type parameter.</typeparam>
            <returns>True if the read succeeded, false otherwise</returns>
        </member>
        <member name="M:CoCoL.ChannelExtensions.Write``1(CoCoL.IWriteChannel{``0},``0)">
            <summary>
            Write to the channel in a blocking manner
            </summary>
            <param name="value">The value to write into the channel</param>
            <param name="self">The channel to read from</param>
            <typeparam name="T">The channel data type parameter.</typeparam>
        </member>
        <member name="M:CoCoL.ChannelExtensions.Write``1(CoCoL.IWriteChannel{``0},``0,System.TimeSpan)">
            <summary>
            Write to the channel in a blocking manner
            </summary>
            <param name="value">The value to write into the channel</param>
            <param name="self">The channel to read from</param>
            <param name="timeout">The maximum time to wait for an available slot</param>
            <typeparam name="T">The channel data type parameter.</typeparam>
        </member>
        <member name="M:CoCoL.ChannelExtensions.TryWrite``1(CoCoL.IWriteChannel{``0},``0)">
            <summary>
            Write to the channel in a probing manner
            </summary>
            <param name="value">The value to write into the channel</param>
            <param name="self">The channel to read from</param>
            <typeparam name="T">The channel data type parameter.</typeparam>
            <returns>True if the write succeeded, false otherwise</returns>
        </member>
        <member name="M:CoCoL.ChannelExtensions.Retire(CoCoL.IRetireAbleChannel,System.Boolean)">
            <summary>
            Leave the channel in a blocking manner
            </summary>
            <param name="self">The channel to leave.</param>
            <param name="immediate">Set to <c>true</c> if the channel is retired immediately.</param>
        </member>
        <member name="M:CoCoL.ChannelExtensions.Leave(CoCoL.IJoinAbleChannel,System.Boolean)">
            <summary>
            Leave the channel in a blocking manner
            </summary>
            <param name="self">The channel to leave.</param>
            <param name="asReader">Set to <c>true</c> if leaving as reader and <c>false</c> if leaving as writer.</param>
        </member>
        <member name="M:CoCoL.ChannelExtensions.Join(CoCoL.IJoinAbleChannel,System.Boolean)">
            <summary>
            Join the channel in a blocking manner
            </summary>
            <param name="self">The channel to join.</param>
            <param name="asReader">Set to <c>true</c> if joining as reader and <c>false</c> if joining as writer.</param>
        </member>
        <member name="M:CoCoL.ChannelExtensions.Leave(CoCoL.IJoinAbleChannelEnd)">
            <summary>
            Leave the channel in a blocking manner
            </summary>
            <param name="self">The channel to leave.</param>
        </member>
        <member name="M:CoCoL.ChannelExtensions.Join(CoCoL.IJoinAbleChannelEnd)">
            <summary>
            Join the channel in a blocking manner
            </summary>
            <param name="self">The channel to join.</param>
        </member>
        <member name="M:CoCoL.ChannelExtensions.ReadFromAny``1(CoCoL.MultiChannelSetRead{``0})">
            <summary>
            Read from the channel set in a blocking manner
            </summary>
            <param name="self">The channels to read from</param>
            <typeparam name="T">The channel data type parameter.</typeparam>
            <returns>The value read from a channel</returns>
        </member>
        <member name="M:CoCoL.ChannelExtensions.ReadFromAny``1(CoCoL.MultiChannelSetRead{``0},CoCoL.IReadChannel{``0}@)">
            <summary>
            Read from the channel set in a blocking manner
            </summary>
            <param name="self">The channels to read from</param>
            <param name="channel">The channel written to</param>
            <typeparam name="T">The channel data type parameter.</typeparam>
            <returns>The value read from a channel</returns>
        </member>
        <member name="M:CoCoL.ChannelExtensions.ReadFromAny``1(CoCoL.MultiChannelSetRead{``0},CoCoL.IReadChannel{``0}@,System.TimeSpan)">
            <summary>
            Read from the channel set in a blocking manner
            </summary>
            <param name="self">The channels to read from</param>
            <param name="channel">The channel written to</param>
            <param name="timeout">The maximum time to wait for a value</param>
            <typeparam name="T">The channel data type parameter.</typeparam>
            <returns>The value read from a channel</returns>
        </member>
        <member name="M:CoCoL.ChannelExtensions.TryReadFromAny``1(CoCoL.MultiChannelSetRead{``0},``0@,CoCoL.IReadChannel{``0}@)">
            <summary>
            Read from the channel set in a probing manner
            </summary>
            <param name="self">The channels to read from</param>
            <param name="value">The value that was read</param>
            <param name="channel">The channel read from</param>
            <typeparam name="T">The channel data type parameter.</typeparam>
            <returns>The value read from a channel</returns>
        </member>
        <member name="M:CoCoL.ChannelExtensions.TryReadFromAny``1(CoCoL.MultiChannelSetRead{``0},``0@)">
            <summary>
            Read from the channel set in a probing manner
            </summary>
            <param name="self">The channels to read from</param>
            <param name="value">The value read</param>
            <typeparam name="T">The channel data type parameter.</typeparam>
            <returns>The value read from a channel</returns>
        </member>
        <member name="M:CoCoL.ChannelExtensions.ReadFromAny``1(CoCoL.MultiChannelSetRead{``0},System.TimeSpan)">
            <summary>
            Read from the channel set in a blocking manner
            </summary>
            <param name="self">The channels to read from</param>
            <param name="timeout">The maximum time to wait for a value</param>
            <returns>The value read from a channel</returns>
            <typeparam name="T">The channel data type parameter.</typeparam>
        </member>
        <member name="M:CoCoL.ChannelExtensions.WriteToAny``1(CoCoL.MultiChannelSetWrite{``0},``0)">
            <summary>
            Write to the channel set in a blocking manner
            </summary>
            <param name="self">The channels to read from</param>
            <param name="value">The value to write into the channel</param>
            <typeparam name="T">The channel data type parameter.</typeparam>
        </member>
        <member name="M:CoCoL.ChannelExtensions.WriteToAny``1(CoCoL.MultiChannelSetWrite{``0},``0,System.TimeSpan)">
            <summary>
            Write to the channel set in a blocking manner
            </summary>
            <param name="self">The channels to read from</param>
            <param name="timeout">The maximum time to wait for a slot</param>
            <param name="value">The value to write into the channel</param>
            <typeparam name="T">The channel data type parameter.</typeparam>
        </member>
        <member name="M:CoCoL.ChannelExtensions.TryWriteToAny``1(CoCoL.MultiChannelSetWrite{``0},``0)">
            <summary>
            Read from the channel set in a probing manner
            </summary>
            <param name="self">The channels to read from</param>
            <param name="value">The value to write into the channel</param>
            <typeparam name="T">The channel data type parameter.</typeparam>
        </member>
        <member name="M:CoCoL.ChannelExtensions.TryWriteToAny``1(CoCoL.MultiChannelSetWrite{``0},``0,CoCoL.IWriteChannel{``0}@)">
            <summary>
            Read from the channel set in a probing manner
            </summary>
            <param name="self">The channels to read from</param>
            <param name="channel">The channel written to</param>
            <param name="value">The value to write into the channel</param>
            <typeparam name="T">The channel data type parameter.</typeparam>
        </member>
        <member name="M:CoCoL.ChannelExtensions.Retire``1(CoCoL.MultiChannelSetRead{``0},System.Boolean)">
            <summary>
            Invokes the retire method on all channels in the set
            </summary>
            <param name="self">The channels to retire</param>
            <param name="immediate">A value indicating if the retire is performed immediately.</param>
            <typeparam name="T">The channel data type parameter.</typeparam>
        </member>
        <member name="M:CoCoL.ChannelExtensions.Retire``1(CoCoL.MultiChannelSetWrite{``0},System.Boolean)">
            <summary>
            Invokes the retire method on all channels in the set
            </summary>
            <param name="self">The channels to retire</param>
            <param name="immediate">A value indicating if the retire is performed immediately.</param>
            <typeparam name="T">The channel data type parameter.</typeparam>
        </member>
        <member name="M:CoCoL.ChannelExtensions.AsRead``1(CoCoL.IChannel{``0})">
            <summary>
            Returns the channel as a read channel
            </summary>
            <returns>The channel as a read channel</returns>
            <param name="channel">The channel to cast.</param>
            <typeparam name="T">The channel data type.</typeparam>
        </member>
        <member name="M:CoCoL.ChannelExtensions.AsWrite``1(CoCoL.IChannel{``0})">
            <summary>
            Returns the channel as a write channel
            </summary>
            <returns>The channel as a write channel</returns>
            <param name="channel">The channel to cast.</param>
            <typeparam name="T">The channel data type.</typeparam>
        </member>
        <member name="M:CoCoL.ChannelExtensions.AsUntyped``1(CoCoL.IChannel{``0})">
            <summary>
            Returns the channel as an untyped channel
            </summary>
            <returns>The untyped channel.</returns>
            <param name="channel">The channel to untype.</param>
            <typeparam name="T">The type of the channel.</typeparam>
        </member>
        <member name="M:CoCoL.ChannelExtensions.AsReadOnly``1(CoCoL.IReadChannel{``0})">
            <summary>
            Returns the channel as an IDisposable read-only channel.
            The returned instance must be Disposed.
            </summary>
            <returns>The channel as a read-only channel</returns>
            <param name="channel">The channel to wrap.</param>
            <typeparam name="T">The channel data type.</typeparam>
        </member>
        <member name="M:CoCoL.ChannelExtensions.AsWriteOnly``1(CoCoL.IWriteChannel{``0})">
            <summary>
            Returns the channel as an IDisposable write-only channel.
            The returned instance must be Disposed.
            </summary>
            <returns>The channel as a write-only channel</returns>
            <param name="channel">The channel to wrap.</param>
            <typeparam name="T">The channel data type.</typeparam>
        </member>
        <member name="M:CoCoL.ChannelExtensions.RetireAsync``1(System.Collections.Generic.IEnumerable{CoCoL.IChannel{``0}},System.Boolean)">
            <summary>
            Retires all channels in the list
            </summary>
            <param name="list">The list of channels to retire</param>
            <param name="immediate">Retires the channel without processing the queue, which may cause lost messages</param>
            <typeparam name="T">The channel data type.</typeparam>
        </member>
        <member name="M:CoCoL.ChannelExtensions.Retire``1(System.Collections.Generic.IEnumerable{CoCoL.IChannel{``0}},System.Boolean)">
            <summary>
            Retires all channels in the list
            </summary>
            <param name="list">The list of channels to retire</param>
            <param name="immediate">Retires the channel without processing the queue, which may cause lost messages</param>
            <typeparam name="T">The channel data type.</typeparam>
        </member>
        <member name="M:CoCoL.ChannelExtensions.Read(CoCoL.IUntypedChannel)">
            <summary>
            Reads the channel synchronously.
            </summary>
            <returns>The value read.</returns>
            <param name="self">The channel to read.</param>
        </member>
        <member name="M:CoCoL.ChannelExtensions.Read(CoCoL.IUntypedChannel,System.TimeSpan,CoCoL.ITwoPhaseOffer)">
            <summary>
            Reads the channel asynchronously.
            </summary>
            <returns>The value read.</returns>
            <param name="self">The channel to read.</param>
            <param name="offer">The two-phase offer.</param>
            <param name="timeout">The read timeout.</param>
        </member>
        <member name="M:CoCoL.ChannelExtensions.ReadAsync(CoCoL.IUntypedChannel)">
            <summary>
            Reads the channel asynchronously.
            </summary>
            <returns>The task for awaiting completion.</returns>
            <param name="self">The channel to read.</param>
        </member>
        <member name="M:CoCoL.ChannelExtensions.Write(CoCoL.IUntypedChannel,System.Object)">
            <summary>
            Writes the channel synchronously
            </summary>
            <param name="self">The channel to write.</param>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:CoCoL.ChannelExtensions.Write(CoCoL.IUntypedChannel,System.Object,System.TimeSpan,CoCoL.ITwoPhaseOffer)">
            <summary>
            Writes the channel synchronously
            </summary>
            <param name="self">The channel to write.</param>
            <param name="value">The value to write.</param>
            <param name="timeout">The write timeout.</param>
            <param name="offer">The two-phase offer instance or null.</param>
        </member>
        <member name="M:CoCoL.ChannelExtensions.WriteAsync(CoCoL.IUntypedChannel,System.Object)">
            <summary>
            Writes the channel asynchronously
            </summary>
            <returns>The task for awaiting completion.</returns>
            <param name="self">The channel to write.</param>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:CoCoL.ChannelExtensions.ReadAsync(CoCoL.IUntypedChannel,System.TimeSpan,CoCoL.ITwoPhaseOffer)">
            <summary>
            Reads the channel asynchronously.
            </summary>
            <returns>The task for awaiting completion.</returns>
            <param name="self">The channel to read.</param>
            <param name="offer">The two-phase offer.</param>
            <param name="timeout">The read timeout.</param>
        </member>
        <member name="M:CoCoL.ChannelExtensions.WriteAsync(CoCoL.IUntypedChannel,System.Object,System.TimeSpan,CoCoL.ITwoPhaseOffer)">
            <summary>
            Writes the channel asynchronously
            </summary>
            <returns>The task for awaiting completion.</returns>
            <param name="self">The channel to write.</param>
            <param name="offer">The two-phase offer.</param>
            <param name="value">The value to write.</param>
            <param name="timeout">The write timeout.</param>
        </member>
        <member name="T:CoCoL.MultiChannelPriority">
            <summary>
            Priorities for selecting a channel when multiple are available
            </summary>
        </member>
        <member name="F:CoCoL.MultiChannelPriority.Any">
            <summary>
            No preference, select any, same as First
            </summary>
        </member>
        <member name="F:CoCoL.MultiChannelPriority.First">
            <summary>
            Select the first channel in the list that matches
            </summary>
        </member>
        <member name="F:CoCoL.MultiChannelPriority.Random">
            <summary>
            Select a random channel
            </summary>
        </member>
        <member name="F:CoCoL.MultiChannelPriority.Fair">
            <summary>
            Select the least used channel
            </summary>
        </member>
        <member name="T:CoCoL.QueueOverflowStrategy">
            <summary>
            The strategies for expiring pending operations on overflow
            </summary>
        </member>
        <member name="F:CoCoL.QueueOverflowStrategy.FIFO">
            <summary>
            First in, first out.
            Expires the oldest entry and inserts a new request as the newest
            </summary>
        </member>
        <member name="F:CoCoL.QueueOverflowStrategy.LIFO">
            <summary>
            Last in, first out.
            Expires most recent entry and inserts a request there instead
            </summary>
        </member>
        <member name="F:CoCoL.QueueOverflowStrategy.Reject">
            <summary>
            Keeps the current set of requests and discards the new request
            </summary>
        </member>
        <member name="T:CoCoL.INamedItem">
            <summary>
            Interface for naming an item
            </summary>
        </member>
        <member name="P:CoCoL.INamedItem.Name">
            <summary>
            Gets the name of the item
            </summary>
            <value>The name of this item</value>
        </member>
        <member name="T:CoCoL.IRetireAbleChannel">
            <summary>
            Represents and interface that is retire-able
            </summary>
        </member>
        <member name="M:CoCoL.IRetireAbleChannel.RetireAsync">
            <summary>
            Stops this channel from processing messages
            </summary>
            <returns>An awaitable task</returns>
        </member>
        <member name="M:CoCoL.IRetireAbleChannel.RetireAsync(System.Boolean)">
            <summary>
            Stops this channel from processing messages
            </summary>
            <param name="immediate">Retires the channel without processing the queue, which may cause lost messages</param>
            <returns>An awaitable task</returns>
        </member>
        <member name="P:CoCoL.IRetireAbleChannel.IsRetiredAsync">
            <summary>
            Gets a value indicating whether this <see cref="T:CoCoL.IRetireAbleChannel"/> is retired.
            </summary>
            <value><c>true</c> if is retired; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:CoCoL.IJoinAbleChannel">
            <summary>
            Interface for a channel that can be joined
            </summary>
        </member>
        <member name="M:CoCoL.IJoinAbleChannel.JoinAsync(System.Boolean)">
            <summary>
            Join the channel
            </summary>
            <param name="asReader"><c>true</c> if joining as a reader, <c>false</c> otherwise</param>
            <returns>An awaitable task</returns>
        </member>
        <member name="M:CoCoL.IJoinAbleChannel.LeaveAsync(System.Boolean)">
            <summary>
            Leave the channel.
            </summary>
            <param name="asReader"><c>true</c> if leaving as a reader, <c>false</c> otherwise</param>
            <returns>An awaitable task</returns>
        </member>
        <member name="T:CoCoL.IJoinAbleChannelEnd">
            <summary>
            Interface for a channel that can be joined
            </summary>
        </member>
        <member name="M:CoCoL.IJoinAbleChannelEnd.JoinAsync">
            <summary>
            Join the channel
            </summary>
            <returns>An awaitable task</returns>
        </member>
        <member name="M:CoCoL.IJoinAbleChannelEnd.LeaveAsync">
            <summary>
            Leave the channel.
            </summary>
            <returns>An awaitable task</returns>
        </member>
        <member name="T:CoCoL.IReadChannel`1">
            <summary>
            Interface for the read-end of a channel that supports continuation
            </summary>
        </member>
        <member name="M:CoCoL.IReadChannel`1.ReadAsync(System.TimeSpan,CoCoL.ITwoPhaseOffer)">
            <summary>
            Registers a desire to read from the channel
            </summary>
            <param name="offer">A callback method for offering an item, use null to unconditionally accept</param>
            <param name="timeout">The time to wait for the operation, use zero to return a timeout immediately if no items can be read. Use a negative span to wait forever.</param>
        </member>
        <member name="M:CoCoL.IReadChannel`1.ReadAsync(CoCoL.ITwoPhaseOffer)">
            <summary>
            Registers a desire to read from the channel
            </summary>
            <param name="offer">A callback method for offering an item, use null to unconditionally accept</param>
        </member>
        <member name="T:CoCoL.IWriteChannel`1">
            <summary>
            Interface for the write-end of a channel that supports continuation
            </summary>
        </member>
        <member name="M:CoCoL.IWriteChannel`1.WriteAsync(`0,CoCoL.ITwoPhaseOffer)">
            <summary>
            Registers a desire to write to the channel
            </summary>
            <param name="offer">A callback method for offering an item, use null to unconditionally accept</param>
            <param name="value">The value to write to the channel.</param>
        </member>
        <member name="M:CoCoL.IWriteChannel`1.WriteAsync(`0,System.TimeSpan,CoCoL.ITwoPhaseOffer)">
            <summary>
            Registers a desire to write to the channel
            </summary>
            <param name="offer">A callback method for offering an item, use null to unconditionally accept</param>
            <param name="value">The value to write to the channel.</param>
            <param name="timeout">The time to wait for the operation, use zero to return a timeout immediately if no items can be read. Use a negative span to wait forever.</param>
        </member>
        <member name="T:CoCoL.IWriteChannelEnd`1">
            <summary>
            Interface for the write-end of a joinable channel that supports continuation
            </summary>
        </member>
        <member name="T:CoCoL.IReadChannelEnd`1">
            <summary>
            Interface for the read-end of a joinable channel that supports continuation
            </summary>
        </member>
        <member name="T:CoCoL.IChannel`1">
            <summary>
            Interface for a communication channel the supports continuation
            </summary>
        </member>
        <member name="T:CoCoL.IUntypedChannel">
            <summary>
            Marker interface to work with mixed-type channels
            </summary>
        </member>
        <member name="T:CoCoL.IProcess">
            <summary>
            Interface for a process
            </summary>
        </member>
        <member name="M:CoCoL.IProcess.Run">
            <summary>
            The method invoked to run the process blocking
            </summary>
        </member>
        <member name="T:CoCoL.IAsyncProcess">
            <summary>
            Interface for a process that runs asyncronously
            </summary>
        </member>
        <member name="M:CoCoL.IAsyncProcess.RunAsync">
            <summary>
            Runs the process asynchronously.
            </summary>
            <returns>The task.</returns>
        </member>
        <member name="T:CoCoL.ITwoPhaseOffer">
            <summary>
            A two-phase model where a read or write request is offered,
            and either accepted by both or rejected if consensus could not
            be reached
            </summary>
        </member>
        <member name="M:CoCoL.ITwoPhaseOffer.OfferAsync(System.Object)">
            <summary>
            Starts the two-phase sequence
            </summary>
            <param name="caller">The offer initiator.</param>
        </member>
        <member name="M:CoCoL.ITwoPhaseOffer.CommitAsync(System.Object)">
            <summary>
            Commits the two-phase sequence
            </summary>
            <param name="caller">The offer initiator.</param>
        </member>
        <member name="M:CoCoL.ITwoPhaseOffer.WithdrawAsync(System.Object)">
            <summary>
            Cancels the two-phase sequence
            </summary>
            <param name="caller">The offer initiator.</param>
        </member>
        <member name="T:CoCoL.IThreadPool">
            <summary>
            Interface for a thread pool implementation
            </summary>
        </member>
        <member name="M:CoCoL.IThreadPool.QueueItem(System.Action)">
            <summary>
            Puts an item into the work queue
            </summary>
            <param name="a">The work item.</param>
        </member>
        <member name="M:CoCoL.IThreadPool.QueueItem(System.Action{System.Object},System.Object)">
            <summary>
            Puts an item into the work queue
            </summary>
            <param name="a">The work item.</param>
            <param name="item">An optional callback parameter.</param>
        </member>
        <member name="M:CoCoL.IThreadPool.QueueTask(System.Action)">
            <summary>
            Puts an item into the work queue
            </summary>
            <param name="a">The work item.</param>
            <returns>The awaitable task.</returns>
        </member>
        <member name="T:CoCoL.IFinishAbleThreadPool">
            <summary>
            Interface for a threadpool that supports finishing
            </summary>
        </member>
        <member name="M:CoCoL.IFinishAbleThreadPool.EnsureFinishedAsync(System.TimeSpan)">
            <summary>
            Ensures that the threadpool is finished or throws an exception
            </summary>
            <param name="waittime">The maximum time to wait for completion.</param>
        </member>
        <member name="T:CoCoL.SortedChannelList`1">
            <summary>
            Helper class for optimized storage of a fair-priority sorted list
            </summary>
        </member>
        <member name="F:CoCoL.SortedChannelList`1.m_split">
            <summary>
            The index where the arrays are split, such that
            any index &lt; split is in the top half, where
            all values are the same
            </summary>
        </member>
        <member name="F:CoCoL.SortedChannelList`1.m_totalUsage">
            <summary>
            The total number of usages
            </summary>
        </member>
        <member name="F:CoCoL.SortedChannelList`1.m_usageCounts">
            <summary>
            The count for the number of times each channel has been used
            </summary>
        </member>
        <member name="F:CoCoL.SortedChannelList`1.m_channels">
            <summary>
            The sorted list of channels, such that the index in
            m_channels and m_usageCounts match
            </summary>
        </member>
        <member name="F:CoCoL.SortedChannelList`1.m_channelLookup">
            <summary>
            A channel lookup for constant time mapping a channel to the index
            </summary>
        </member>
        <member name="M:CoCoL.SortedChannelList`1.#ctor(`0[])">
            <summary>
            Initializes a new instance of the <see cref="T:CoCoL.SortedChannelList`1"/> class.
            </summary>
            <param name="channels">The channels to keep sorted</param>
        </member>
        <member name="M:CoCoL.SortedChannelList`1.NotifyUsed(System.Object)">
            <summary>
            Callback method invoked when a channel has been used
            </summary>
            <param name="item">The channel that was used</param>
        </member>
        <member name="M:CoCoL.SortedChannelList`1.Swap(System.Int32,System.Int32)">
            <summary>
            Swaps the elements with index a and b
            </summary>
            <param name="a">One index</param>
            <param name="b">Another index</param>
        </member>
        <member name="P:CoCoL.SortedChannelList`1.Channels">
            <summary>
            Gets the channels in sorted order
            </summary>
            <value>The channels.</value>
        </member>
        <member name="T:CoCoL.MultiChannelSetRead`1">
            <summary>
            A collection of channels that can be read or written
            </summary>
        </member>
        <member name="F:CoCoL.MultiChannelSetRead`1.m_channels">
            <summary>
            The channels to consider
            </summary>
        </member>
        <member name="F:CoCoL.MultiChannelSetRead`1.m_sortedChannels">
            <summary>
            The usage of the channels, used for tracking fair usage
            </summary>
        </member>
        <member name="F:CoCoL.MultiChannelSetRead`1.m_priority">
            <summary>
            The order in which the channels are picked
            </summary>
        </member>
        <member name="M:CoCoL.MultiChannelSetRead`1.#ctor(CoCoL.MultiChannelPriority,CoCoL.IReadChannel{`0}[])">
            <summary>
            Initializes a new instance of the <see cref="T:CoCoL.MultiChannelSetRead`1"/> class.
            </summary>
            <param name="priority">The priority to use when selecting a channel.</param>
            <param name="channels">The channels to consider.</param>
        </member>
        <member name="M:CoCoL.MultiChannelSetRead`1.#ctor(CoCoL.IReadChannel{`0}[])">
            <summary>
            Initializes a new instance of the <see cref="T:CoCoL.MultiChannelSetRead`1"/> class.
            </summary>
            <param name="channels">The channels to consider.</param>
        </member>
        <member name="M:CoCoL.MultiChannelSetRead`1.#ctor(System.Collections.Generic.IEnumerable{CoCoL.IReadChannel{`0}},CoCoL.MultiChannelPriority)">
            <summary>
            Initializes a new instance of the <see cref="T:CoCoL.MultiChannelSetRead`1"/> class.
            </summary>
            <param name="priority">The priority to use when selecting a channel.</param>
            <param name="channels">The channels to consider.</param>
        </member>
        <member name="M:CoCoL.MultiChannelSetRead`1.#ctor(System.Collections.Generic.IEnumerable{CoCoL.IReadChannel{`0}})">
            <summary>
            Initializes a new instance of the <see cref="T:CoCoL.MultiChannelSetRead`1"/> class.
            </summary>
            <param name="channels">The channels to consider.</param>
        </member>
        <member name="M:CoCoL.MultiChannelSetRead`1.ReadFromAnyAsync">
            <summary>
            Reads from any channel
            </summary>
        </member>
        <member name="M:CoCoL.MultiChannelSetRead`1.ReadFromAnyAsync(System.TimeSpan)">
            <summary>
            Reads from any channel
            </summary>
            <param name="timeout">The maximum time to wait for a result.</param>
        </member>
        <member name="M:CoCoL.MultiChannelSetRead`1.RetireAsync(System.Boolean)">
            <summary>
            Retires all channels in the set
            </summary>
            <param name="immediate">Retires the channel without processing the queue, which may cause lost messages</param>
            <returns>An awaitable task</returns>
        </member>
        <member name="P:CoCoL.MultiChannelSetRead`1.Channels">
            <summary>
            Gets all channels in the set
            </summary>
            <value>The channels in the set</value>
        </member>
        <member name="T:CoCoL.MultiChannelSetWrite`1">
            <summary>
            A collection of channels that can be read or written
            </summary>
        </member>
        <member name="F:CoCoL.MultiChannelSetWrite`1.m_channels">
            <summary>
            The channels to consider
            </summary>
        </member>
        <member name="F:CoCoL.MultiChannelSetWrite`1.m_sortedChannels">
            <summary>
            The usage of the channels, used for tracking fair usage
            </summary>
        </member>
        <member name="F:CoCoL.MultiChannelSetWrite`1.m_priority">
            <summary>
            The order in which the channels are picked
            </summary>
        </member>
        <member name="M:CoCoL.MultiChannelSetWrite`1.#ctor(CoCoL.MultiChannelPriority,CoCoL.IWriteChannel{`0}[])">
            <summary>
            Initializes a new instance of the <see cref="T:CoCoL.MultiChannelSetWrite`1"/> class.
            </summary>
            <param name="priority">The priority to use when selecting a channel.</param>
            <param name="channels">The channels to consider.</param>
        </member>
        <member name="M:CoCoL.MultiChannelSetWrite`1.#ctor(CoCoL.IWriteChannel{`0}[])">
            <summary>
            Initializes a new instance of the <see cref="T:CoCoL.MultiChannelSetWrite`1"/> class.
            </summary>
            <param name="channels">The channels to consider.</param>
        </member>
        <member name="M:CoCoL.MultiChannelSetWrite`1.#ctor(System.Collections.Generic.IEnumerable{CoCoL.IWriteChannel{`0}},CoCoL.MultiChannelPriority)">
            <summary>
            Initializes a new instance of the <see cref="T:CoCoL.MultiChannelSetWrite`1"/> class.
            </summary>
            <param name="priority">The priority to use when selecting a channel.</param>
            <param name="channels">The channels to consider.</param>
        </member>
        <member name="M:CoCoL.MultiChannelSetWrite`1.#ctor(System.Collections.Generic.IEnumerable{CoCoL.IWriteChannel{`0}})">
            <summary>
            Initializes a new instance of the <see cref="T:CoCoL.MultiChannelSetWrite`1"/> class.
            </summary>
            <param name="channels">The channels to consider.</param>
        </member>
        <member name="M:CoCoL.MultiChannelSetWrite`1.WriteToAnyAsync(`0)">
            <summary>
            Writes to any of the channels.
            </summary>
            <param name="value">The value to write into the channel.</param>
        </member>
        <member name="M:CoCoL.MultiChannelSetWrite`1.WriteToAnyAsync(`0,System.TimeSpan)">
            <summary>
            Writes to any of the channels.
            </summary>
            <param name="value">The value to write into the channel.</param>
            <param name="timeout">The maximum time to wait for any channel to become ready.</param>
        </member>
        <member name="M:CoCoL.MultiChannelSetWrite`1.RetireAsync(System.Boolean)">
            <summary>
            Retires all channels in the set
            </summary>
            <param name="immediate">Retires the channel without processing the queue, which may cause lost messages</param>
            <returns>An awaitable task</returns>
        </member>
        <member name="P:CoCoL.MultiChannelSetWrite`1.Channels">
            <summary>
            Gets all channels in the set
            </summary>
            <value>The channels in the set</value>
        </member>
        <member name="T:CoCoL.ExpirationManager">
            <summary>
            Expiration manager, keeps track of all channels with pending expirations
            </summary>
        </member>
        <member name="F:CoCoL.ExpirationManager.ALLOWED_ADVANCE_EXPIRE_TICKS">
            <summary>
            The maximum number of ticks we allow the events to be scheduled in advance of the desired expiry time.
            Setting this to zero gives more accurate channel timeouts in exchange for a few repeated calls
            </summary>
        </member>
        <member name="F:CoCoL.ExpirationManager.MIN_ALLOWED_WAIT">
            <summary>
            The minimum number of ticks we allow time to wait, this reduces repeated re-schedules
            if the Task.Delay() calls arrive in advance.
            This usually only has an effect when ALLOWED_ADVANCE_EXPIRE_TICKS is less than 10000.
            
            If ALLOWED_ADVANCE_EXPIRE_TICKS and MIN_ALLOWED_WAIT are set to zero,
            expiration events have less extra delay, but occasionally cause extra CPU load
            </summary>
        </member>
        <member name="F:CoCoL.ExpirationManager._ex">
            <summary>
            The implementation of an expiration manager, for easy replacement
            </summary>
        </member>
        <member name="M:CoCoL.ExpirationManager.AddExpirationCallback(System.DateTime,System.Action)">
            <summary>
            Registers a method for callback
            </summary>
            <param name="expires">The time when the expiration occurs</param>
            <param name="callback">The method to call on expiration</param>
        </member>
        <member name="T:CoCoL.ExpirationManager.ExpirationManagerImpl">
            <summary>
            Implementation of an expiration manager
            </summary>
        </member>
        <member name="F:CoCoL.ExpirationManager.ExpirationManagerImpl.m_lock">
            <summary>
            The lock that provides exclusive access to the lookup table
            </summary>
        </member>
        <member name="F:CoCoL.ExpirationManager.ExpirationManagerImpl.m_nextInvoke">
            <summary>
            The time at which the timer should trigger next
            </summary>
        </member>
        <member name="F:CoCoL.ExpirationManager.ExpirationManagerImpl.m_expiryTable">
            <summary>
            The table of registered callbacks for timeouts
            </summary>
        </member>
        <member name="F:CoCoL.ExpirationManager.ExpirationManagerImpl.m_timerToken">
            <summary>
            The token that controls the timer
            </summary>
        </member>
        <member name="F:CoCoL.ExpirationManager.ExpirationManagerImpl.m_timerTask">
            <summary>
            The task that represents the running timer
            </summary>
        </member>
        <member name="M:CoCoL.ExpirationManager.ExpirationManagerImpl.AddExpirationCallback(System.DateTime,System.Action)">
            <summary>
            Registers a method for callback
            </summary>
            <param name="expires">The time when the expiration occurs</param>
            <param name="callback">The method to call on expiration</param>
        </member>
        <member name="M:CoCoL.ExpirationManager.ExpirationManagerImpl.RescheduleTimer(System.DateTime)">
            <summary>
            Reschedules the timer.
            </summary>
            <param name="next">The time when the next tick should occur</param>
        </member>
        <member name="M:CoCoL.ExpirationManager.ExpirationManagerImpl.RunTimer(System.Threading.Tasks.Task)">
            <summary>
            Callback method for handling a timer event
            </summary>
            <param name="task">Unused parameter for matching the callback signature</param>
        </member>
        <member name="T:CoCoL.MultisetResult`1">
            <summary>
            Result from a mult-channel operation
            </summary>
        </member>
        <member name="F:CoCoL.MultisetResult`1.Value">
            <summary>
            The result value
            </summary>
        </member>
        <member name="F:CoCoL.MultisetResult`1.Channel">
            <summary>
            The channel being read from
            </summary>
        </member>
        <member name="M:CoCoL.MultisetResult`1.#ctor(`0,CoCoL.IReadChannel{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:CoCoL.MultisetResult`1"/> struct.
            </summary>
            <param name="value">The value read</param>
            <param name="channel">The channel read from</param>
        </member>
        <member name="T:CoCoL.MultiChannelAccess">
            <summary>
            Helper class for performing multi-channel access
            </summary>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.RequestRead``1(CoCoL.IReadChannel{``0})">
            <summary>
            Creates a read request for the given channel.
            </summary>
            <param name="self">The channel to request the read from.</param>
            <typeparam name="T">The type of the channel.</typeparam>
            <returns>The created request</returns>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.RequestWrite``1(CoCoL.IWriteChannel{``0},``0)">
            <summary>
            Create a write request for the given channel.
            </summary>
            <param name="self">The channel to request the write to.</param>
            <param name="value">The value to write.</param>
            <typeparam name="T">The type of the channel.</typeparam>
            <returns>The created request</returns>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.RequestRead(CoCoL.IUntypedChannel)">
            <summary>
            Creates a read request for the given channel.
            </summary>
            <param name="self">The channel to request the read from.</param>
            <returns>The created request</returns>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.RequestWrite(CoCoL.IUntypedChannel,System.Object)">
            <summary>
            Create a write request for the given channel.
            </summary>
            <param name="self">The channel to request the write to.</param>
            <param name="value">The value to write.</param>
            <returns>The created request</returns>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.CreateSet``1(System.Collections.Generic.IEnumerable{CoCoL.IReadChannel{``0}},CoCoL.MultiChannelPriority)">
            <summary>
            Creates a multichannelset from a list of channels
            </summary>
            <returns>The multichannel set.</returns>
            <param name="channels">The channels to make the set from.</param>
            <param name="priority">The channel priority.</param>
            <typeparam name="T">The type of the channel.</typeparam>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.CreateSet``1(System.Collections.Generic.IEnumerable{CoCoL.IWriteChannel{``0}},CoCoL.MultiChannelPriority)">
            <summary>
            Creates a multichannelset from a list of channels
            </summary>
            <returns>The multichannel set.</returns>
            <param name="channels">The channels to make the set from.</param>
            <param name="priority">The channel priority.</param>
            <typeparam name="T">The type of the channel.</typeparam>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadFromAnyAsync``1(System.TimeSpan,CoCoL.MultiChannelPriority,CoCoL.IReadChannel{``0}[])">
            <summary>
            Reads from any of the specified channels
            </summary>
            <param name="channels">The list of channels to call.</param>
            <param name="timeout">The maximum time to wait for a value to read.</param>
            <param name="priority">The priority used to select channels, if multiple channels have a value that can be read.</param>
            <typeparam name="T">The channel data type.</typeparam>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadFromAnyAsync``1(System.TimeSpan,CoCoL.IReadChannel{``0}[])">
            <summary>
            Reads from any of the specified channels
            </summary>
            <param name="channels">The list of channels to call.</param>
            <param name="timeout">The maximum time to wait for a value to read.</param>
            <typeparam name="T">The channel data type.</typeparam>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadFromAnyAsync``1(CoCoL.MultiChannelPriority,CoCoL.IReadChannel{``0}[])">
            <summary>
            Reads from any of the specified channels
            </summary>
            <param name="channels">The list of channels to call.</param>
            <param name="priority">The priority used to select channels, if multiple channels have a value that can be read.</param>
            <typeparam name="T">The channel data type.</typeparam>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadFromAnyAsync``1(CoCoL.IReadChannel{``0}[])">
            <summary>
            Reads from any of the specified channels
            </summary>
            <param name="channels">The list of channels to call.</param>
            <typeparam name="T">The channel data type.</typeparam>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadFromAnyAsync``1(System.Collections.Generic.IEnumerable{CoCoL.IReadChannel{``0}})">
            <summary>
            Reads from any of the specified channels
            </summary>
            <param name="channels">The list of channels to call.</param>
            <typeparam name="T">The channel data type.</typeparam>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadFromAnyAsync``1(System.Collections.Generic.IEnumerable{CoCoL.IReadChannel{``0}},System.TimeSpan)">
            <summary>
            Reads from any of the specified channels
            </summary>
            <param name="channels">The list of channels to call.</param>
            <param name="timeout">The maximum time to wait for a value to read.</param>
            <typeparam name="T">The channel data type.</typeparam>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadFromAnyAsync``1(System.Collections.Generic.IEnumerable{CoCoL.IReadChannel{``0}},CoCoL.MultiChannelPriority)">
            <summary>
            Reads from any of the specified channels
            </summary>
            <param name="channels">The list of channels to call.</param>
            <param name="priority">The priority used to select channels, if multiple channels have a value that can be read.</param>
            <typeparam name="T">The channel data type.</typeparam>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadFromAnyAsync``1(System.Collections.Generic.IEnumerable{CoCoL.IReadChannel{``0}},System.TimeSpan,CoCoL.MultiChannelPriority)">
            <summary>
            Reads from any of the specified channels
            </summary>
            <param name="channels">The list of channels to attempt to read from.</param>
            <param name="timeout">The maximum time to wait for a value to read.</param>
            <param name="priority">The priority used to select a channel, if multiple channels have a value that can be read.</param>
            <typeparam name="T">The channel data type.</typeparam>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadFromAnyAsync``1(System.Action{System.Object},System.Collections.Generic.IEnumerable{CoCoL.IReadChannel{``0}},System.TimeSpan,CoCoL.MultiChannelPriority)">
            <summary>
            Reads from any of the specified channels
            </summary>
            <param name="callback">The method to call when the read completes, or null.</param>
            <param name="channels">The list of channels to attempt to read from.</param>
            <param name="timeout">The maximum time to wait for a value to read.</param>
            <param name="priority">The priority used to select a channel, if multiple channels have a value that can be read.</param>
            <typeparam name="T">The channel data type.</typeparam>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.WriteToAnyAsync``1(``0,System.TimeSpan,CoCoL.MultiChannelPriority,CoCoL.IWriteChannel{``0}[])">
            <summary>
            Writes to any of the specified channels
            </summary>
            <param name="value">The value to write to the channel.</param>
            <param name="channels">The list of channels to attempt to write.</param>
            <param name="timeout">The maximum time to wait for a channel to become ready for writing.</param>
            <param name="priority">The priority used to select a channel, if multiple channels have a value that can be written.</param>
            <typeparam name="T">The channel data type.</typeparam>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.WriteToAnyAsync``1(``0,System.TimeSpan,CoCoL.IWriteChannel{``0}[])">
            <summary>
            Writes to any of the specified channels
            </summary>
            <param name="value">The value to write to the channel.</param>
            <param name="channels">The list of channels to attempt to write.</param>
            <param name="timeout">The maximum time to wait for a channel to become ready for writing.</param>
            <typeparam name="T">The channel data type.</typeparam>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.WriteToAnyAsync``1(``0,CoCoL.MultiChannelPriority,CoCoL.IWriteChannel{``0}[])">
            <summary>
            Writes to any of the specified channels
            </summary>
            <param name="value">The value to write to the channel.</param>
            <param name="channels">The list of channels to attempt to write.</param>
            <param name="priority">The priority used to select a channel, if multiple channels have a value that can be written.</param>
            <typeparam name="T">The channel data type.</typeparam>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.WriteToAnyAsync``1(``0,CoCoL.IWriteChannel{``0}[])">
            <summary>
            Writes to any of the specified channels
            </summary>
            <param name="value">The value to write to the channel.</param>
            <param name="channels">The list of channels to attempt to write.</param>
            <typeparam name="T">The channel data type.</typeparam>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.WriteToAnyAsync``1(``0,System.Collections.Generic.IEnumerable{CoCoL.IWriteChannel{``0}},System.TimeSpan)">
            <summary>
            Writes to any of the specified channels
            </summary>
            <param name="value">The value to write to the channel.</param>
            <param name="channels">The list of channels to attempt to write.</param>
            <param name="timeout">The maximum time to wait for a channel to become ready for writing.</param>
            <typeparam name="T">The channel data type.</typeparam>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.WriteToAnyAsync``1(``0,System.Collections.Generic.IEnumerable{CoCoL.IWriteChannel{``0}},CoCoL.MultiChannelPriority)">
            <summary>
            Writes to any of the specified channels
            </summary>
            <param name="value">The value to write to the channel.</param>
            <param name="channels">The list of channels to attempt to write.</param>
            <param name="priority">The priority used to select a channel, if multiple channels have a value that can be written.</param>
            <typeparam name="T">The channel data type.</typeparam>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.WriteToAnyAsync``1(``0,System.Collections.Generic.IEnumerable{CoCoL.IWriteChannel{``0}},System.TimeSpan,CoCoL.MultiChannelPriority)">
            <summary>
            Writes to any of the specified channels
            </summary>
            <param name="value">The value to write to the channel.</param>
            <param name="channels">The list of channels to attempt to write.</param>
            <param name="timeout">The maximum time to wait for a channel to become ready for writing.</param>
            <param name="priority">The priority used to select a channel, if multiple channels have a value that can be written.</param>
            <typeparam name="T">The channel data type.</typeparam>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.WriteToAnyAsync``1(System.Collections.Generic.IEnumerable{CoCoL.IWriteChannel{``0}},``0,System.TimeSpan)">
            <summary>
            Writes to any of the specified channels
            </summary>
            <param name="value">The value to write to the channel.</param>
            <param name="channels">The list of channels to attempt to write.</param>
            <param name="timeout">The maximum time to wait for a channel to become ready for writing.</param>
            <typeparam name="T">The channel data type.</typeparam>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.WriteToAnyAsync``1(System.Collections.Generic.IEnumerable{CoCoL.IWriteChannel{``0}},``0,CoCoL.MultiChannelPriority)">
            <summary>
            Writes to any of the specified channels
            </summary>
            <param name="value">The value to write to the channel.</param>
            <param name="channels">The list of channels to attempt to write.</param>
            <param name="priority">The priority used to select a channel, if multiple channels have a value that can be written.</param>
            <typeparam name="T">The channel data type.</typeparam>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.WriteToAnyAsync``1(System.Collections.Generic.IEnumerable{CoCoL.IWriteChannel{``0}},``0,System.TimeSpan,CoCoL.MultiChannelPriority)">
            <summary>
            Writes to any of the specified channels
            </summary>
            <param name="value">The value to write to the channel.</param>
            <param name="channels">The list of channels to attempt to write.</param>
            <param name="timeout">The maximum time to wait for a channel to become ready for writing.</param>
            <param name="priority">The priority used to select a channel, if multiple channels have a value that can be written.</param>
            <typeparam name="T">The channel data type.</typeparam>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.WriteToAnyAsync``1(System.Action{System.Object},``0,System.Collections.Generic.IEnumerable{CoCoL.IWriteChannel{``0}},System.TimeSpan,CoCoL.MultiChannelPriority)">
            <summary>
            Writes to any of the specified channels
            </summary>
            <param name="callback">The method to call when the write completes, or null.</param>
            <param name="value">The value to write to the channel.</param>
            <param name="channels">The list of channels to attempt to write.</param>
            <param name="timeout">The maximum time to wait for a channel to become ready for writing.</param>
            <param name="priority">The priority used to select a channel, if multiple channels have a value that can be written.</param>
            <typeparam name="T">The channel data type.</typeparam>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadOrWriteAnyAsync``1(System.TimeSpan,CoCoL.MultiChannelPriority,CoCoL.MultisetRequest{``0}[])">
            <summary>
            Reads from any of the specified channels
            </summary>
            <param name="requests">The list of requests</param>
            <param name="timeout">The maximum time to wait for a value to read.</param>
            <param name="priority">The priority used to select channels, if multiple channels have a value that can be read.</param>
            <typeparam name="T">The channel data type.</typeparam>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadOrWriteAnyAsync``1(System.TimeSpan,CoCoL.MultisetRequest{``0}[])">
            <summary>
            Reads from any of the specified channels
            </summary>
            <param name="requests">The list of requests</param>
            <param name="timeout">The maximum time to wait for a value to read.</param>
            <typeparam name="T">The channel data type.</typeparam>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadOrWriteAnyAsync``1(CoCoL.MultiChannelPriority,CoCoL.MultisetRequest{``0}[])">
            <summary>
            Reads from any of the specified channels
            </summary>
            <param name="requests">The list of requests</param>
            <param name="priority">The priority used to select channels, if multiple channels have a value that can be read.</param>
            <typeparam name="T">The channel data type.</typeparam>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadOrWriteAnyAsync``1(CoCoL.MultisetRequest{``0}[])">
            <summary>
            Reads from any of the specified channels
            </summary>
            <param name="requests">The list of requests</param>
            <typeparam name="T">The channel data type.</typeparam>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadOrWriteAnyAsync``1(System.Collections.Generic.IEnumerable{CoCoL.MultisetRequest{``0}},System.TimeSpan)">
            <summary>
            Reads from any of the specified channels
            </summary>
            <param name="requests">The list of requests</param>
            <param name="timeout">The maximum time to wait for a value to read.</param>
            <typeparam name="T">The channel data type.</typeparam>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadOrWriteAnyAsync``1(System.Collections.Generic.IEnumerable{CoCoL.MultisetRequest{``0}},CoCoL.MultiChannelPriority)">
            <summary>
            Reads from any of the specified channels
            </summary>
            <param name="requests">The list of requests</param>
            <param name="priority">The priority used to select channels, if multiple channels have a value that can be read.</param>
            <typeparam name="T">The channel data type.</typeparam>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadOrWriteAnyAsync``1(System.Collections.Generic.IEnumerable{CoCoL.MultisetRequest{``0}},System.TimeSpan,CoCoL.MultiChannelPriority)">
            <summary>
            Reads from any of the specified channels
            </summary>
            <param name="requests">The list of requests</param>
            <param name="timeout">The maximum time to wait for a value to read.</param>
            <param name="priority">The priority used to select a channel, if multiple channels have a value that can be read.</param>
            <typeparam name="T">The channel data type.</typeparam>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadOrWriteAnyAsync``1(System.Collections.Generic.IEnumerable{CoCoL.MultisetRequest{``0}},System.Action{System.Object},System.TimeSpan,CoCoL.MultiChannelPriority)">
            <summary>
            Reads from any of the specified channels
            </summary>
            <param name="callback">The method to call when the read completes, or null.</param>
            <param name="requests">The list of requests</param>
            <param name="timeout">The maximum time to wait for a value to read.</param>
            <param name="priority">The priority used to select a channel, if multiple channels have a value that can be read.</param>
            <typeparam name="T">The channel data type.</typeparam>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadOrWriteAnyAsync``1(System.Action{System.Object},System.Collections.Generic.IEnumerable{CoCoL.MultisetRequest{``0}},System.TimeSpan,CoCoL.MultiChannelPriority)">
            <summary>
            Reads from any of the specified channels
            </summary>
            <param name="callback">The method to call when the read completes, or null.</param>
            <param name="requests">The list of requests</param>
            <param name="timeout">The maximum time to wait for a value to read.</param>
            <param name="priority">The priority used to select a channel, if multiple channels have a value that can be read.</param>
            <typeparam name="T">The channel data type.</typeparam>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.Shuffle``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Takes an IEnumerable and returns it in random order
            </summary>
            <returns>The shuffled list</returns>
            <param name="source">The input source</param>
            <typeparam name="T">The IEnumerable type.</typeparam>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadFromAnyAsync(System.TimeSpan,CoCoL.MultiChannelPriority,CoCoL.IUntypedChannel[])">
            <summary>
            Reads from any of the specified channels
            </summary>
            <param name="channels">The list of channels to call.</param>
            <param name="timeout">The maximum time to wait for a value to read.</param>
            <param name="priority">The priority used to select channels, if multiple channels have a value that can be read.</param>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadFromAnyAsync(System.TimeSpan,CoCoL.IUntypedChannel[])">
            <summary>
            Reads from any of the specified channels
            </summary>
            <param name="channels">The list of channels to call.</param>
            <param name="timeout">The maximum time to wait for a value to read.</param>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadFromAnyAsync(CoCoL.MultiChannelPriority,CoCoL.IUntypedChannel[])">
            <summary>
            Reads from any of the specified channels
            </summary>
            <param name="channels">The list of channels to call.</param>
            <param name="priority">The priority used to select channels, if multiple channels have a value that can be read.</param>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadFromAnyAsync(CoCoL.IUntypedChannel[])">
            <summary>
            Reads from any of the specified channels
            </summary>
            <param name="channels">The list of channels to call.</param>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadFromAnyAsync(System.Collections.Generic.IEnumerable{CoCoL.IUntypedChannel},System.TimeSpan)">
            <summary>
            Reads from any of the specified channels
            </summary>
            <param name="channels">The list of channels to call.</param>
            <param name="timeout">The maximum time to wait for a value to read.</param>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadFromAnyAsync(System.Collections.Generic.IEnumerable{CoCoL.IUntypedChannel},CoCoL.MultiChannelPriority)">
            <summary>
            Reads from any of the specified channels
            </summary>
            <param name="channels">The list of channels to call.</param>
            <param name="priority">The priority used to select channels, if multiple channels have a value that can be read.</param>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadFromAnyAsync(System.Collections.Generic.IEnumerable{CoCoL.IUntypedChannel},System.TimeSpan,CoCoL.MultiChannelPriority)">
            <summary>
            Reads from any of the specified channels
            </summary>
            <param name="channels">The list of channels to attempt to read from.</param>
            <param name="timeout">The maximum time to wait for a value to read.</param>
            <param name="priority">The priority used to select a channel, if multiple channels have a value that can be read.</param>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadFromAnyAsync(System.Action{System.Object},System.Collections.Generic.IEnumerable{CoCoL.IUntypedChannel},System.TimeSpan,CoCoL.MultiChannelPriority)">
            <summary>
            Reads from any of the specified channels
            </summary>
            <param name="callback">The method to call after the read completes.</param>
            <param name="channels">The list of channels to attempt to read from.</param>
            <param name="timeout">The maximum time to wait for a value to read.</param>
            <param name="priority">The priority used to select a channel, if multiple channels have a value that can be read.</param>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadFromAnyAsync(System.TimeSpan,CoCoL.MultiChannelPriority,CoCoL.IMultisetRequestUntyped[])">
            <summary>
            Reads from any of the specified channels
            </summary>
            <param name="requests">The list of requests.</param>
            <param name="timeout">The maximum time to wait for a value to read.</param>
            <param name="priority">The priority used to select channels, if multiple channels have a value that can be read.</param>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadFromAnyAsync(System.TimeSpan,CoCoL.IMultisetRequestUntyped[])">
            <summary>
            Reads from any of the specified channels
            </summary>
            <param name="requests">The list of requests.</param>
            <param name="timeout">The maximum time to wait for a value to read.</param>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadFromAnyAsync(CoCoL.MultiChannelPriority,CoCoL.IMultisetRequestUntyped[])">
            <summary>
            Reads from any of the specified channels
            </summary>
            <param name="requests">The list of requests.</param>
            <param name="priority">The priority used to select channels, if multiple channels have a value that can be read.</param>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadFromAnyAsync(CoCoL.IMultisetRequestUntyped[])">
            <summary>
            Reads from any of the specified channels
            </summary>
            <param name="requests">The list of requests.</param>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadFromAnyAsync(System.Collections.Generic.IEnumerable{CoCoL.IMultisetRequestUntyped})">
            <summary>
            Reads from any of the specified channels
            </summary>
            <param name="requests">The list of requests.</param>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadFromAnyAsync(System.Collections.Generic.IEnumerable{CoCoL.IMultisetRequestUntyped},System.TimeSpan)">
            <summary>
            Reads from any of the specified channels
            </summary>
            <param name="requests">The list of requests.</param>
            <param name="timeout">The maximum time to wait for a value to read.</param>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadFromAnyAsync(System.Collections.Generic.IEnumerable{CoCoL.IMultisetRequestUntyped},CoCoL.MultiChannelPriority)">
            <summary>
            Reads from any of the specified channels
            </summary>
            <param name="requests">The list of requests.</param>
            <param name="priority">The priority used to select channels, if multiple channels have a value that can be read.</param>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadFromAnyAsync(System.Collections.Generic.IEnumerable{CoCoL.IMultisetRequestUntyped},System.TimeSpan,CoCoL.MultiChannelPriority)">
            <summary>
            Reads from any of the specified channels
            </summary>
            <param name="requests">The list of requests.</param>
            <param name="timeout">The maximum time to wait for a value to read.</param>
            <param name="priority">The priority used to select a channel, if multiple channels have a value that can be read.</param>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadFromAnyAsync(System.Action{System.Object},System.Collections.Generic.IEnumerable{CoCoL.IMultisetRequestUntyped},System.TimeSpan,CoCoL.MultiChannelPriority)">
            <summary>
            Reads from any of the specified channels
            </summary>
            <param name="callback">The method to call when the read completes, or null.</param>
            <param name="requests">The list of requests.</param>
            <param name="timeout">The maximum time to wait for a value to read.</param>
            <param name="priority">The priority used to select a channel, if multiple channels have a value that can be read.</param>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.WriteToAnyAsync(System.TimeSpan,CoCoL.MultiChannelPriority,CoCoL.IMultisetRequestUntyped[])">
            <summary>
            Writes to any of the specified channels
            </summary>
            <param name="requests">The list of channels to attempt to write.</param>
            <param name="timeout">The maximum time to wait for a channel to become ready for writing.</param>
            <param name="priority">The priority used to select a channel, if multiple channels have a value that can be written.</param>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.WriteToAnyAsync(System.TimeSpan,CoCoL.IMultisetRequestUntyped[])">
            <summary>
            Writes to any of the specified channels
            </summary>
            <param name="requests">The list of channels to attempt to write.</param>
            <param name="timeout">The maximum time to wait for a channel to become ready for writing.</param>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.WriteToAnyAsync(CoCoL.MultiChannelPriority,CoCoL.IMultisetRequestUntyped[])">
            <summary>
            Writes to any of the specified channels
            </summary>
            <param name="requests">The list of channels to attempt to write.</param>
            <param name="priority">The priority used to select a channel, if multiple channels have a value that can be written.</param>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.WriteToAnyAsync(CoCoL.IMultisetRequestUntyped[])">
            <summary>
            Writes to any of the specified channels
            </summary>
            <param name="requests">The list of channels to attempt to write.</param>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.WriteToAnyAsync(System.Collections.Generic.IEnumerable{CoCoL.IMultisetRequestUntyped})">
            <summary>
            Writes to any of the specified channels
            </summary>
            <param name="requests">The list of channels to attempt to write.</param>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.WriteToAnyAsync(System.Collections.Generic.IEnumerable{CoCoL.IMultisetRequestUntyped},System.TimeSpan)">
            <summary>
            Writes to any of the specified channels
            </summary>
            <param name="requests">The list of channels to attempt to write.</param>
            <param name="timeout">The maximum time to wait for a channel to become ready for writing.</param>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.WriteToAnyAsync(System.Collections.Generic.IEnumerable{CoCoL.IMultisetRequestUntyped},CoCoL.MultiChannelPriority)">
            <summary>
            Writes to any of the specified channels
            </summary>
            <param name="requests">The list of channels to attempt to write.</param>
            <param name="priority">The priority used to select a channel, if multiple channels have a value that can be written.</param>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.WriteToAnyAsync(System.Collections.Generic.IEnumerable{CoCoL.IMultisetRequestUntyped},System.TimeSpan,CoCoL.MultiChannelPriority)">
            <summary>
            Writes to any of the specified channels
            </summary>
            <param name="requests">The list of channels to attempt to write.</param>
            <param name="timeout">The maximum time to wait for a channel to become ready for writing.</param>
            <param name="priority">The priority used to select a channel, if multiple channels have a value that can be written.</param>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadOrWriteAnyAsync(System.TimeSpan,CoCoL.MultiChannelPriority,CoCoL.IMultisetRequestUntyped[])">
            <summary>
            Reads or writes any of the specified requests
            </summary>
            <param name="requests">The list of channels to call.</param>
            <param name="timeout">The maximum time to wait for a value to read.</param>
            <param name="priority">The priority used to select channels, if multiple channels have a value that can be read.</param>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadOrWriteAnyAsync(System.TimeSpan,CoCoL.IMultisetRequestUntyped[])">
            <summary>
            Reads or writes any of the specified requests
            </summary>
            <param name="requests">The list of channels to call.</param>
            <param name="timeout">The maximum time to wait for a value to read.</param>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadOrWriteAnyAsync(CoCoL.MultiChannelPriority,CoCoL.IMultisetRequestUntyped[])">
            <summary>
            Reads or writes any of the specified requests
            </summary>
            <param name="requests">The list of channels to call.</param>
            <param name="priority">The priority used to select channels, if multiple channels have a value that can be read.</param>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadOrWriteAnyAsync(CoCoL.IMultisetRequestUntyped[])">
            <summary>
            Reads or writes any of the specified requests
            </summary>
            <param name="requests">The list of channels to call.</param>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadOrWriteAnyAsync``1(System.Collections.Generic.IEnumerable{CoCoL.IMultisetRequestUntyped})">
            <summary>
            Reads or writes any of the specified requests
            </summary>
            <param name="requests">The list of channels to call.</param>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadOrWriteAnyAsync``1(System.Collections.Generic.IEnumerable{CoCoL.IMultisetRequestUntyped},System.TimeSpan)">
            <summary>
            Reads or writes any of the specified requests
            </summary>
            <param name="requests">The list of channels to call.</param>
            <param name="timeout">The maximum time to wait for a value to read.</param>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadOrWriteAnyAsync``1(System.Collections.Generic.IEnumerable{CoCoL.IMultisetRequestUntyped},CoCoL.MultiChannelPriority)">
            <summary>
            Reads or writes any of the specified requests
            </summary>
            <param name="requests">The list of channels to call.</param>
            <param name="priority">The priority used to select channels, if multiple channels have a value that can be read.</param>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadOrWriteAnyAsync``1(System.Collections.Generic.IEnumerable{CoCoL.IMultisetRequestUntyped},System.TimeSpan,CoCoL.MultiChannelPriority)">
            <summary>
            Reads or writes any of the specified requests
            </summary>
            <param name="requests">The list of requests.</param>
            <param name="timeout">The maximum time to wait for a value to read.</param>
            <param name="priority">The priority used to select a channel, if multiple channels have a value that can be read.</param>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadOrWriteAnyAsync``1(System.Collections.Generic.IEnumerable{CoCoL.IMultisetRequestUntyped},System.Action{System.Object},System.TimeSpan,CoCoL.MultiChannelPriority)">
            <summary>
            Reads or writes any of the specified requests
            </summary>
            <param name="callback">The method to call when the read completes, or null.</param>
            <param name="requests">The list of requests.</param>
            <param name="timeout">The maximum time to wait for a value to read.</param>
            <param name="priority">The priority used to select a channel, if multiple channels have a value that can be read.</param>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadOrWriteAnyAsync``1(System.Action{System.Object},System.Collections.Generic.IEnumerable{CoCoL.IMultisetRequestUntyped},System.TimeSpan,CoCoL.MultiChannelPriority)">
            <summary>
            Reads or writes any of the specified requests
            </summary>
            <param name="callback">The method to call when the read completes, or null.</param>
            <param name="requests">The list of requests.</param>
            <param name="timeout">The maximum time to wait for a value to read.</param>
            <param name="priority">The priority used to select a channel, if multiple channels have a value that can be read.</param>
        </member>
        <member name="M:CoCoL.MultiChannelAccess.ReadOrWriteAnyAsync(System.Action{System.Object},System.Collections.Generic.IEnumerable{CoCoL.IMultisetRequestUntyped},System.TimeSpan,CoCoL.MultiChannelPriority)">
            <summary>
            Reads or writes any of the specified requests
            </summary>
            <param name="callback">The method to call when the read completes, or null.</param>
            <param name="requests">The list of requests.</param>
            <param name="timeout">The maximum time to wait for a value to read.</param>
            <param name="priority">The priority used to select a channel, if multiple channels have a value that can be read.</param>
        </member>
        <member name="T:CoCoL.MultisetRequest">
            <summary>
            A request for a multi-channel operation
            </summary>
        </member>
        <member name="M:CoCoL.MultisetRequest.Read``1(CoCoL.IReadChannel{``0})">
            <summary>
            Constructs a request to read a channel.
            </summary>
            <param name="channel">The channel to read from.</param>
        </member>
        <member name="M:CoCoL.MultisetRequest.Write``1(``0,CoCoL.IWriteChannel{``0})">
            <summary>
            Constructs a request to write a channel.
            </summary>
            <param name="value">The value to write to the channel.</param>
            <param name="channel">The channel to write to.</param>
        </member>
        <member name="T:CoCoL.MultisetRequest`1">
            <summary>
            A request for a multi-channel operation
            </summary>
        </member>
        <member name="F:CoCoL.MultisetRequest`1.Value">
            <summary>
            The result value
            </summary>
        </member>
        <member name="F:CoCoL.MultisetRequest`1.ReadChannel">
            <summary>
            The channel being read from
            </summary>
        </member>
        <member name="F:CoCoL.MultisetRequest`1.WriteChannel">
            <summary>
            The channel being written to
            </summary>
        </member>
        <member name="F:CoCoL.MultisetRequest`1.IsRead">
            <summary>
            Gets a value indicating if this is a read operation
            </summary>
        </member>
        <member name="M:CoCoL.MultisetRequest`1.#ctor(`0,CoCoL.IReadChannel{`0},CoCoL.IWriteChannel{`0},System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:CoCoL.MultisetRequest`1"/> struct.
            </summary>
            <param name="value">The value to write</param>
            <param name="readChannel">The channel to read.</param>
            <param name="writeChannel">The channel to write.</param>
            <param name="read"><c>true</c> if this is a read operation, <c>false</c> otherwise</param>
        </member>
        <member name="M:CoCoL.MultisetRequest`1.Read(CoCoL.IReadChannel{`0})">
            <summary>
            Constructs a request to read a channel.
            </summary>
            <param name="channel">The channel to read from.</param>
        </member>
        <member name="M:CoCoL.MultisetRequest`1.Write(`0,CoCoL.IWriteChannel{`0})">
            <summary>
            Constructs a request to write a channel.
            </summary>
            <param name="value">The value to write to the channel.</param>
            <param name="channel">The channel to write to.</param>
        </member>
        <member name="P:CoCoL.MultisetRequest`1.CoCoL#IMultisetRequestUntyped#Value">
            <summary>
            Gets the boxed value.
            </summary>
            <value>The value.</value>
        </member>
        <member name="P:CoCoL.MultisetRequest`1.CoCoL#IMultisetRequestUntyped#Channel">
            <summary>
            Gets the channel.
            </summary>
            <value>The channel.</value>
        </member>
        <member name="P:CoCoL.MultisetRequest`1.CoCoL#IMultisetRequestUntyped#IsRead">
            <summary>
            Gets a value indicating whether this instance is a read request.
            </summary>
            <value><c>true</c> if this instance is read request; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:CoCoL.SingleOffer`1">
            <summary>
            A helper for ensuring we only offer to a single recipient
            </summary>
        </member>
        <member name="F:CoCoL.SingleOffer`1.TRUE">
            <summary>
            Workaround to use System.Thread.Interlocked.Increment,
            which does not work on booleans
            </summary>
        </member>
        <member name="F:CoCoL.SingleOffer`1.m_taken">
            <summary>
            True if this item is already taken, false otherwise
            </summary>
        </member>
        <member name="F:CoCoL.SingleOffer`1.m_lock">
            <summary>
            The lock for providing exclusive access
            </summary>
        </member>
        <member name="F:CoCoL.SingleOffer`1.m_commitCallback">
            <summary>
            An optional callback for reporting if the offer was taken
            </summary>
        </member>
        <member name="F:CoCoL.SingleOffer`1.m_tcs">
            <summary>
            The completion source to signal on completio
            </summary>
        </member>
        <member name="F:CoCoL.SingleOffer`1.m_timeout">
            <summary>
            The time the offer expires
            </summary>
        </member>
        <member name="F:CoCoL.SingleOffer`1.m_isFirst">
            <summary>
            A value indicating if the request is the first to set the TaskCompletionSource
            </summary>
        </member>
        <member name="F:CoCoL.SingleOffer`1.m_isLocked">
            <summary>
            Keeping track of the lock state
            </summary>
        </member>
        <member name="F:CoCoL.SingleOffer`1.m_offerCaller">
            <summary>
            The offer caller instance
            </summary>
        </member>
        <member name="F:CoCoL.SingleOffer`1.m_offers">
            <summary>
            The list of offers
            </summary>
        </member>
        <member name="M:CoCoL.SingleOffer`1.#ctor">
            <summary>
            Creates a new SingleOffer instance with no expiration date
            </summary>
        </member>
        <member name="M:CoCoL.SingleOffer`1.#ctor(System.Threading.Tasks.TaskCompletionSource{`0},System.DateTime)">
            <summary>
            Creates a new SingleOffer instance
            </summary>
            <param name="tcs">The task completion source</param>
            <param name="timeout">The timeout value</param>
        </member>
        <member name="M:CoCoL.SingleOffer`1.SetCommitCallback(System.Action{System.Object})">
            <summary>
            Register a callback method, which is invoked if the two-phase sequence is committed
            </summary>
            <param name="cb">The callback method.</param>
        </member>
        <member name="P:CoCoL.SingleOffer`1.IsTaken">
            <summary>
            Gets a value indicating whether this instance is taken.
            </summary>
            <value><c>true</c> if this instance is taken; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:CoCoL.SingleOffer`1.OfferAsync(System.Object)">
            <summary>
            Starts the two-phase sequence
            </summary>
            <param name="caller">The offer initiator.</param>
            <returns>The awaitable result.</returns>
        </member>
        <member name="M:CoCoL.SingleOffer`1.CommitAsync(System.Object)">
            <summary>
            Commits the two-phase sequence
            </summary>
            <param name="caller">The offer initiator.</param>
        </member>
        <member name="M:CoCoL.SingleOffer`1.WithdrawAsync(System.Object)">
            <summary>
            Cancels the two-phase sequence
            </summary>
            <param name="caller">The offer initiator.</param>
        </member>
        <member name="M:CoCoL.SingleOffer`1.AtomicIsFirst">
            <summary>
            Gets a value indicating if this call is the first to set the TaskCompletionSource,
            and atomically updates the flag to return false to all subsequent callers
            </summary>
            <returns><c>true</c>, if the call is the first, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:CoCoL.SingleOffer`1.ExpirationCallback">
            <summary>
            Callback method that activates expiration
            </summary>
        </member>
        <member name="M:CoCoL.SingleOffer`1.ProbePhaseComplete">
            <summary>
            The caller indicates that the offer is now registered in all places
            </summary>
        </member>
        <member name="T:CoCoL.IMultisetRequestUntyped">
            <summary>
            A request in an untyped (or multi-type) multi-channel operation
            </summary>
        </member>
        <member name="P:CoCoL.IMultisetRequestUntyped.Value">
            <summary>
            The result value
            </summary>
        </member>
        <member name="P:CoCoL.IMultisetRequestUntyped.Channel">
            <summary>
            The channel being read from
            </summary>
        </member>
        <member name="P:CoCoL.IMultisetRequestUntyped.IsRead">
            <summary>
            Gets a value indicating if this is a read operation
            </summary>
        </member>
        <member name="T:CoCoL.RetiredException">
            <summary>
            Exception which is thrown when attempting to access a retired channel
            </summary>
        </member>
        <member name="F:CoCoL.RetiredException.ChannelName">
            <summary>
            The name of the channel that is retired
            </summary>
        </member>
        <member name="M:CoCoL.RetiredException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:CoCoL.RetiredException"/> class.
            </summary>
            <param name="channelname">The name of the channel</param>
        </member>
        <member name="M:CoCoL.RetiredException.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:CoCoL.RetiredException"/> class.
            </summary>
            <param name="message">The error message.</param>
            <param name="channelname">The name of the channel</param>
        </member>
        <member name="M:CoCoL.RetiredException.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:CoCoL.RetiredException"/> class.
            </summary>
            <param name="message">The error message.</param>
            <param name="ex">The inner exception.</param>
            <param name="channelname">The name of the channel</param>
        </member>
        <member name="T:CoCoL.ChannelOverflowException">
            <summary>
            Exception which is thrown when a channel attempt is discarded from overflow
            </summary>
        </member>
        <member name="F:CoCoL.ChannelOverflowException.ChannelName">
            <summary>
            The name of the channel that is overflown
            </summary>
        </member>
        <member name="M:CoCoL.ChannelOverflowException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:CoCoL.ChannelOverflowException"/> class.
            </summary>
            <param name="channelname">The name of the channel</param>
        </member>
        <member name="M:CoCoL.ChannelOverflowException.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:CoCoL.ChannelOverflowException"/> class.
            </summary>
            <param name="message">The error message.</param>
            <param name="channelname">The name of the channel</param>
        </member>
        <member name="M:CoCoL.ChannelOverflowException.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:CoCoL.ChannelOverflowException"/> class.
            </summary>
            <param name="message">The error message.</param>
            <param name="ex">The inner exception.</param>
            <param name="channelname">The name of the channel</param>
        </member>
        <member name="T:CoCoL.ProcessAttribute">
            <summary>
            Attribute that indicates that this class is a process, and indicates how many instances should be started
            </summary>
        </member>
        <member name="F:CoCoL.ProcessAttribute.ProcessCount">
            <summary>
            The number of processes
            </summary>
        </member>
        <member name="M:CoCoL.ProcessAttribute.#ctor(System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:CoCoL.ProcessAttribute"/> class.
            </summary>
            <param name="count">The number of processes to launch.</param>
        </member>
        <member name="T:CoCoL.ChannelNameScope">
            <summary>
            Enumeration for choosing the name scope
            </summary>
        </member>
        <member name="F:CoCoL.ChannelNameScope.Local">
            <summary>
            Use the current local name scope
            </summary>
        </member>
        <member name="F:CoCoL.ChannelNameScope.Parent">
            <summary>
            Use the current parent name scope
            </summary>
        </member>
        <member name="F:CoCoL.ChannelNameScope.Global">
            <summary>
            Use the global name scope
            </summary>
        </member>
        <member name="T:CoCoL.ChannelNameAttribute">
            <summary>
            Attribute for naming a channel in automatic wireup
            </summary>
        </member>
        <member name="F:CoCoL.ChannelNameAttribute.Name">
            <summary>
            The name of the channel
            </summary>
        </member>
        <member name="F:CoCoL.ChannelNameAttribute.BufferSize">
            <summary>
            The buffer size of the channel
            </summary>
        </member>
        <member name="F:CoCoL.ChannelNameAttribute.TargetScope">
            <summary>
            The target scope.
            </summary>
        </member>
        <member name="F:CoCoL.ChannelNameAttribute.MaxPendingReaders">
            <summary>
            The maximum number of pending readers
            </summary>
        </member>
        <member name="F:CoCoL.ChannelNameAttribute.MaxPendingWriters">
            <summary>
            The maximum number of pendinger writers
            </summary>
        </member>
        <member name="F:CoCoL.ChannelNameAttribute.PendingReadersOverflowStrategy">
            <summary>
            The strategy for selecting pending readers to discard on overflow
            </summary>
        </member>
        <member name="F:CoCoL.ChannelNameAttribute.PendingWritersOverflowStrategy">
            <summary>
            The strategy for selecting pending readers to discard on overflow
            </summary>
        </member>
        <member name="M:CoCoL.ChannelNameAttribute.#ctor(System.String,System.Int32,CoCoL.ChannelNameScope,System.Int32,System.Int32,CoCoL.QueueOverflowStrategy,CoCoL.QueueOverflowStrategy)">
            <summary>
            Initializes a new instance of the <see cref="T:CoCoL.ChannelNameAttribute"/> class.
            </summary>
            <param name="name">The name of the channel.</param>
            <param name="buffersize">The size of the buffer on the created channel</param>
            <param name="targetScope">The scope where the channel is created</param>
            <param name="maxPendingReaders">The maximum number of pending readers. A negative value indicates infinite</param>
            <param name="maxPendingWriters">The maximum number of pending writers. A negative value indicates infinite</param>
            <param name="pendingReadersOverflowStrategy">The strategy for dealing with overflow for read requests</param>
            <param name="pendingWritersOverflowStrategy">The strategy for dealing with overflow for write requests</param>
        </member>
        <member name="T:CoCoL.BroadcastChannelNameAttribute">
            <summary>
            Attribute for naming a channel in automatic wireup
            </summary>
        </member>
        <member name="F:CoCoL.BroadcastChannelNameAttribute.InitialBarrierSize">
            <summary>
            The minimum number of readers required for a broadcast to be performed
            </summary>
        </member>
        <member name="F:CoCoL.BroadcastChannelNameAttribute.MinimumReaders">
            <summary>
            The minimum number of readers required for the first broadcast to be performed
            </summary>
        </member>
        <member name="M:CoCoL.BroadcastChannelNameAttribute.#ctor(System.String,System.Int32,CoCoL.ChannelNameScope,System.Int32,System.Int32,CoCoL.QueueOverflowStrategy,CoCoL.QueueOverflowStrategy,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:CoCoL.BroadcastChannelNameAttribute"/> class.
            </summary>
            <param name="name">The name of the channel.</param>
            <param name="buffersize">The size of the buffer on the created channel</param>
            <param name="targetScope">The scope where the channel is created</param>
            <param name="maxPendingReaders">The maximum number of pending readers. A negative value indicates infinite</param>
            <param name="maxPendingWriters">The maximum number of pending writers. A negative value indicates infinite</param>
            <param name="pendingReadersOverflowStrategy">The strategy for dealing with overflow for read requests</param>
            <param name="pendingWritersOverflowStrategy">The strategy for dealing with overflow for write requests</param>
            <param name="initialBarrierSize">The number of readers required on the channel before sending the first broadcast</param>
            <param name="minimumReaders">The minimum number of readers required on the channel, before a broadcast can be performed</param>
        </member>
        <member name="T:CoCoL.ThreadPool">
            <summary>
            Thread Pool, responsible for queueing work items
            </summary>
        </member>
        <member name="F:CoCoL.ThreadPool.DEFAULT_THREADPOOL">
            <summary>
            The implementation of a thread pool, for easy replacement
            </summary>
        </member>
        <member name="M:CoCoL.ThreadPool.QueueItem(System.Action)">
            <summary>
            Puts an item into the work queue
            </summary>
            <param name="a">The work item.</param>
        </member>
        <member name="M:CoCoL.ThreadPool.QueueItem(System.Action{System.Object},System.Object)">
            <summary>
            Puts an item into the work queue
            </summary>
            <param name="a">The work item.</param>
            <param name="item">An optional callback parameter.</param>
        </member>
        <member name="M:CoCoL.ThreadPool.QueueTask(System.Action)">
            <summary>
            Puts an item into the work queue
            </summary>
            <param name="a">The work item.</param>
            <returns>The awaitable task.</returns>
        </member>
        <member name="T:CoCoL.SystemThreadPoolWrapper">
            <summary>
            The default thread pool implementation, which just wraps the .Net Thread Pool
            </summary>
        </member>
        <member name="M:CoCoL.SystemThreadPoolWrapper.QueueItem(System.Action)">
            <summary>
            Puts an item into the work queue
            </summary>
            <param name="a">The work item.</param>
        </member>
        <member name="M:CoCoL.SystemThreadPoolWrapper.QueueItem(System.Action{System.Object},System.Object)">
            <summary>
            Puts an item into the work queue
            </summary>
            <param name="a">The work item.</param>
            <param name="item">An optional callback parameter.</param>
        </member>
        <member name="M:CoCoL.SystemThreadPoolWrapper.QueueTask(System.Action)">
            <summary>
            Puts an item into the work queue
            </summary>
            <param name="a">The work item.</param>
            <returns>The awaitable task.</returns>
        </member>
        <member name="M:CoCoL.SystemThreadPoolWrapper.Dispose">
            <summary>
            Releases all resource used by the <see cref="T:CoCoL.SystemThreadPoolWrapper"/> object.
            </summary>
            <remarks>Call <see cref="M:CoCoL.SystemThreadPoolWrapper.Dispose"/> when you are finished using the <see cref="T:CoCoL.SystemThreadPoolWrapper"/>. The
            <see cref="M:CoCoL.SystemThreadPoolWrapper.Dispose"/> method leaves the <see cref="T:CoCoL.SystemThreadPoolWrapper"/> in an unusable state. After
            calling <see cref="M:CoCoL.SystemThreadPoolWrapper.Dispose"/>, you must release all references to the <see cref="T:CoCoL.SystemThreadPoolWrapper"/>
            so the garbage collector can reclaim the memory that the <see cref="T:CoCoL.SystemThreadPoolWrapper"/> was occupying.</remarks>
        </member>
        <member name="T:CoCoL.CappedThreadedThreadPool">
            <summary>
            A thread pool that puts a cap on the number of concurrent requests
            </summary>
        </member>
        <member name="F:CoCoL.CappedThreadedThreadPool.m_work">
            <summary>
            The list of pending work
            </summary>
        </member>
        <member name="F:CoCoL.CappedThreadedThreadPool.m_lock">
            <summary>
            The locking object
            </summary>
        </member>
        <member name="F:CoCoL.CappedThreadedThreadPool.m_instances">
            <summary>
            The number of running instances
            </summary>
        </member>
        <member name="F:CoCoL.CappedThreadedThreadPool.m_maxThreads">
            <summary>
            The maximum number of concurrent threads
            </summary>
        </member>
        <member name="F:CoCoL.CappedThreadedThreadPool.m_shutdown">
            <summary>
            True if a shutdown is in progress
            </summary>
        </member>
        <member name="M:CoCoL.CappedThreadedThreadPool.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:CoCoL.CappedThreadedThreadPool"/> class.
            </summary>
            <param name="max_threads">The maximum number of concurrent threads.</param>
        </member>
        <member name="M:CoCoL.CappedThreadedThreadPool.Execute(System.Object)">
            <summary>
            Performs the execution
            </summary>
            <param name="method">The the method to execute.</param>
        </member>
        <member name="M:CoCoL.CappedThreadedThreadPool.QueueItem(System.Action)">
            <summary>
            Puts an item into the work queue
            </summary>
            <param name="a">The work item.</param>
        </member>
        <member name="M:CoCoL.CappedThreadedThreadPool.QueueItem(System.Action{System.Object},System.Object)">
            <summary>
            Puts an item into the work queue
            </summary>
            <param name="a">The work item.</param>
            <param name="item">An optional callback parameter.</param>
        </member>
        <member name="M:CoCoL.CappedThreadedThreadPool.QueueTask(System.Action)">
            <summary>
            Puts an item into the work queue
            </summary>
            <param name="a">The work item.</param>
            <returns>The awaitable task.</returns>
        </member>
        <member name="M:CoCoL.CappedThreadedThreadPool.EnsureFinishedAsync(System.TimeSpan)">
            <summary>
            Ensures that all threads are finished
            </summary>
            <param name="waittime">The time to wait for completion</param>
        </member>
        <member name="M:CoCoL.CappedThreadedThreadPool.Dispose">
            <summary>
            Releases all resource used by the <see cref="T:CoCoL.CappedThreadedThreadPool"/> object.
            </summary>
            <remarks>Call <see cref="M:CoCoL.CappedThreadedThreadPool.Dispose"/> when you are finished using the <see cref="T:CoCoL.CappedThreadedThreadPool"/>. The
            <see cref="M:CoCoL.CappedThreadedThreadPool.Dispose"/> method leaves the <see cref="T:CoCoL.CappedThreadedThreadPool"/> in an unusable state. After
            calling <see cref="M:CoCoL.CappedThreadedThreadPool.Dispose"/>, you must release all references to the <see cref="T:CoCoL.CappedThreadedThreadPool"/>
            so the garbage collector can reclaim the memory that the <see cref="T:CoCoL.CappedThreadedThreadPool"/> was occupying.</remarks>
        </member>
        <member name="T:CoCoL.Timeout">
            <summary>
            Helper class for providing standard timeouts
            </summary>
        </member>
        <member name="F:CoCoL.Timeout.Infinite">
            <summary>
            The timespan used to signal infinite waiting
            </summary>
        </member>
        <member name="F:CoCoL.Timeout.Immediate">
            <summary>
            The timespan used to signal no waiting
            </summary>
        </member>
        <member name="F:CoCoL.Timeout.InfiniteDateTime">
            <summary>
            A marker instance for a wait forever
            </summary>
        </member>
        <member name="T:CoCoL.IGenericTypeHelper">
            <summary>
            Interface to avoid certain reflection methods
            that are not found in the PCL
            </summary>
        </member>
        <member name="M:CoCoL.IGenericTypeHelper.IsTypeT(System.Object)">
            <summary>
            True if the given item is, or derives from, the type parameter T
            </summary>
            <returns><c>true</c> if the given item is, or derives from, the type parameter T; otherwise, <c>false</c>.</returns>
            <param name="item">The instance to check.</param>
        </member>
        <member name="M:CoCoL.IGenericTypeHelper.ReadAsync(CoCoL.IUntypedChannel,System.TimeSpan,CoCoL.ITwoPhaseOffer)">
            <summary>
            Reads from the channel and returns the task
            </summary>
            <returns>The async task.</returns>
            <param name="channel">The channel to read from.</param>
            <param name="offer">The two-phase offer.</param>
            <param name="timeout">The timeout value.</param>
        </member>
        <member name="M:CoCoL.IGenericTypeHelper.WriteAsync(CoCoL.IUntypedChannel,System.Object,System.TimeSpan,CoCoL.ITwoPhaseOffer)">
            <summary>
            Writes the channel and returns the task
            </summary>
            <returns>The async task.</returns>
            <param name="channel">The channel to write to.</param>
            <param name="value">The value to write.</param>
            <param name="offer">The two-phase offer.</param>
            <param name="timeout">The timeout value.</param>
        </member>
        <member name="M:CoCoL.IGenericTypeHelper.RequestRead(CoCoL.IUntypedChannel)">
            <summary>
            Requests a read on the channel.
            </summary>
            <returns>The read request.</returns>
            <param name="channel">The channel to read from.</param>
        </member>
        <member name="M:CoCoL.IGenericTypeHelper.RequestWrite(System.Object,CoCoL.IUntypedChannel)">
            <summary>
            Requests a write on the channel.
            </summary>
            <returns>The write request.</returns>
            <param name="value">The value to write.</param>
            <param name="channel">The channel to write to.</param>
        </member>
        <member name="T:CoCoL.GenericTypeHelper`1">
            <summary>
            Implementation of the generic type helper
            </summary>
        </member>
        <member name="M:CoCoL.GenericTypeHelper`1.IsTypeT(System.Object)">
            <summary>
            True if the given item is, or derives from, the type parameter T
            </summary>
            <returns><c>true</c> if the given item is, or derives from, the type parameter T; otherwise, <c>false</c>.</returns>
            <param name="item">The instance to check.</param>
        </member>
        <member name="M:CoCoL.GenericTypeHelper`1.ReadAsync(CoCoL.IUntypedChannel,System.TimeSpan,CoCoL.ITwoPhaseOffer)">
            <summary>
            Reads from the channel and returns the task
            </summary>
            <returns>The async task.</returns>
            <param name="channel">The channel to read from.</param>
            <param name="offer">The two-phase offer.</param>
            <param name="timeout">The timeout value.</param>
        </member>
        <member name="M:CoCoL.GenericTypeHelper`1.WriteAsync(CoCoL.IUntypedChannel,System.Object,System.TimeSpan,CoCoL.ITwoPhaseOffer)">
            <summary>
            Writes the channel and returns the task
            </summary>
            <returns>The async task.</returns>
            <param name="channel">The channel to write to.</param>
            <param name="value">The value to write.</param>
            <param name="offer">The two-phase offer.</param>
            <param name="timeout">The timeout value.</param>
        </member>
        <member name="M:CoCoL.GenericTypeHelper`1.RequestRead(CoCoL.IUntypedChannel)">
            <summary>
            Requests a read on the channel.
            </summary>
            <returns>The read request.</returns>
            <param name="channel">The channel to read from.</param>
        </member>
        <member name="M:CoCoL.GenericTypeHelper`1.RequestWrite(System.Object,CoCoL.IUntypedChannel)">
            <summary>
            Requests a write on the channel.
            </summary>
            <returns>The write request.</returns>
            <param name="value">The value to write.</param>
            <param name="channel">The channel to write to.</param>
        </member>
        <member name="T:CoCoL.UntypedAccessMethods">
            <summary>
            Class for helping with access to untyped methods through reflection
            </summary>
        </member>
        <member name="M:CoCoL.UntypedAccessMethods.ReadInterface(CoCoL.IUntypedChannel)">
            <summary>
            Gets the IReadChannel&lt;&gt; interface from an untyped channel instance
            </summary>
            <returns>The IReadChannel&lt;&gt; interface.</returns>
            <param name="self">The channel to get the interface from</param>
        </member>
        <member name="M:CoCoL.UntypedAccessMethods.WriteInterface(CoCoL.IUntypedChannel)">
            <summary>
            Gets the IWriteChannel&lt;&gt; interface from an untyped channel instance
            </summary>
            <returns>The IWriteChannel&lt;&gt; interface.</returns>
            <param name="self">The channel to get the interface from</param>
        </member>
        <member name="M:CoCoL.UntypedAccessMethods.CreateReadAccessor(CoCoL.IUntypedChannel)">
            <summary>
            Creates an acessor from the given itemtype
            </summary>
            <returns>The accessor.</returns>
            <param name="item">The item to create the interface for.</param>
        </member>
        <member name="M:CoCoL.UntypedAccessMethods.CreateWriteAccessor(CoCoL.IUntypedChannel)">
            <summary>
            Creates an acessor to an IWriteChannel&lt;&gt;
            </summary>
            <returns>The accessor.</returns>
            <param name="item">The item to create the interface for.</param>
        </member>
        <member name="M:CoCoL.UntypedAccessMethods.CreateAccessor(System.Type)">
            <summary>
            Creates an acessor from the given itemtype, that is the T in IChannel&lt;T&gt;
            </summary>
            <returns>The accessor type.</returns>
            <param name="itemtype">The item type, that is the T in IChannel&lt;T&gt;.</param>
        </member>
        <member name="M:CoCoL.UntypedAccessMethods.GetImplementedGenericInterface_ProbingVersion(System.Object,System.Type)">
            <summary>
            Gets the implemented generic interface from an instance.
            </summary>
            <returns>The implemented generic interface type.</returns>
            <param name="item">The item to examine.</param>
            <param name="interface">The interface type definition.</param>
        </member>
        <member name="M:CoCoL.UntypedAccessMethods.GetImplementedGenericInterface(System.Object,System.Type)">
            <summary>
            Gets the implemented generic interface from an instance.
            </summary>
            <returns>The implemented generic interface type.</returns>
            <param name="item">The item to examine.</param>
            <param name="interface">The interface type definition.</param>
        </member>
        <member name="T:CoCoL.SortedList`2">
            <summary>
            Simple implementation of a sorted list with operations in log(n) time
            </summary>
        </member>
        <member name="F:CoCoL.SortedList`2.m_list">
            <summary>
            The internal list, which is maintained sorted
            </summary>
        </member>
        <member name="M:CoCoL.SortedList`2.Find(`0)">
            <summary>
            Find the index of the specified key, or bitwise inverted value if not found.
            </summary>
            <param name="key">Key.</param>
            <returns>The index of the key in the list, or the bitwise inverse of the closest match</returns>
        </member>
        <member name="M:CoCoL.SortedList`2.Add(`0,`1)">
            <summary>
            Adds the specified key and value to the list
            </summary>
            <param name="key">The key to add.</param>
            <param name="value">The value to add.</param>
        </member>
        <member name="M:CoCoL.SortedList`2.Remove(`0)">
            <summary>
            Removes the item with the given key
            </summary>
            <param name="key">The key to remove.</param>
            <returns><c>True</c> if the entry with the given key was removed, false otherwise</returns>
        </member>
        <member name="M:CoCoL.SortedList`2.TryGetValue(`0,`1@)">
            <summary>
            Gets the value for the specified key, if it exists
            </summary>
            <returns><c>true</c>, if get value was found, <c>false</c> otherwise.</returns>
            <param name="key">The key to look for.</param>
            <param name="value">The matching value.</param>
        </member>
        <member name="P:CoCoL.SortedList`2.Item(`0)">
            <summary>
            Gets or sets the <see cref="T:CoCoL.SortedList`2"/> at the specified index.
            </summary>
            <param name="index">Index.</param>
        </member>
        <member name="P:CoCoL.SortedList`2.First">
            <summary>
            Gets the first entry in the list.
            </summary>
        </member>
        <member name="M:CoCoL.SortedList`2.RemoveAt(System.Int32)">
            <summary>
            Removes the item at the specified index
            </summary>
            <param name="index">Index.</param>
        </member>
        <member name="P:CoCoL.SortedList`2.Count">
            <summary>
            Gets the number of elements in the list.
            </summary>
        </member>
        <member name="M:CoCoL.SortedList`2.GetEnumerator">
            <summary>
            Gets the enumerator.
            </summary>
            <returns>The enumerator.</returns>
        </member>
        <member name="M:CoCoL.SortedList`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets the enumerator.
            </summary>
            <returns>The enumerator.</returns>
        </member>
        <member name="T:CoCoL.ProcessHelper">
            <summary>
            Base class for implementing a communicating process as a class.
            </summary>
        </member>
        <member name="M:CoCoL.ProcessHelper.Start">
            <summary>
            The method that implements this process
            </summary>
        </member>
        <member name="F:CoCoL.ProcessHelper.m_started">
            <summary>
            The task if it has been invoked
            </summary>
        </member>
        <member name="F:CoCoL.ProcessHelper.m_lock">
            <summary>
            The locking object
            </summary>
        </member>
        <member name="M:CoCoL.ProcessHelper.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:CoCoL.ProcessHelper"/> class.
            </summary>
        </member>
        <member name="M:CoCoL.ProcessHelper.Run">
            <summary>
            The method invoked to run the process blocking
            </summary>
        </member>
        <member name="M:CoCoL.ProcessHelper.RunAsync">
            <summary>
            Runs the process asynchronously.
            </summary>
            <returns>The task.</returns>
        </member>
        <member name="M:CoCoL.ProcessHelper.SingleRun">
            <summary>
            Runs the process as a one-shot.
            </summary>
            <returns>The task.</returns>
        </member>
        <member name="M:CoCoL.ProcessHelper.Dispose(System.Boolean)">
            <summary>
            <summary>
            Releases all resource used by the <see cref="T:CoCoL.ProcessHelper"/> object.
            </summary>
            <remarks>Call <see cref="M:CoCoL.ProcessHelper.Dispose"/> when you are finished using the <see cref="T:CoCoL.ProcessHelper"/>. The
            <see cref="M:CoCoL.ProcessHelper.Dispose"/> method leaves the <see cref="T:CoCoL.ProcessHelper"/> in an unusable state. After calling
            <see cref="M:CoCoL.ProcessHelper.Dispose"/>, you must release all references to the <see cref="T:CoCoL.ProcessHelper"/> so the garbage
            collector can reclaim the memory that the <see cref="T:CoCoL.ProcessHelper"/> was occupying.</remarks>
            </summary>
            <param name="disposing">If set to <c>true</c> disposing.</param>
        </member>
        <member name="M:CoCoL.ProcessHelper.Dispose">
            <summary>
            Releases all resource used by the <see cref="T:CoCoL.ProcessHelper"/> object.
            </summary>
            <remarks>Call <see cref="M:CoCoL.ProcessHelper.Dispose"/> when you are finished using the <see cref="T:CoCoL.ProcessHelper"/>. The
            <see cref="M:CoCoL.ProcessHelper.Dispose"/> method leaves the <see cref="T:CoCoL.ProcessHelper"/> in an unusable state. After calling
            <see cref="M:CoCoL.ProcessHelper.Dispose"/>, you must release all references to the <see cref="T:CoCoL.ProcessHelper"/> so the garbage
            collector can reclaim the memory that the <see cref="T:CoCoL.ProcessHelper"/> was occupying.</remarks>
        </member>
        <member name="M:CoCoL.ProcessHelper.GetAwaiter">
            <summary>
            Gets the awaiter.
            </summary>
            <returns>The awaiter.</returns>
        </member>
        <member name="T:CoCoL.ReflectionHelper">
            <summary>
            Class that contains methods for dealing with shortcommings in the PCL reflection library
            </summary>
        </member>
        <member name="T:CoCoL.Loader">
            <summary>
            Helper class for loading statically denfined processes
            </summary>
        </member>
        <member name="M:CoCoL.Loader.StartFromAssembly(System.Reflection.Assembly[])">
            <summary>
            Finds all classes marked as Process and launches them
            </summary>
            <param name="asm">The assemblies to examine.</param>
        </member>
        <member name="M:CoCoL.Loader.StartFromAssembly(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            Finds all classes marked as Process and launches them
            </summary>
            <param name="asm">The assemblies to examine.</param>
        </member>
        <member name="M:CoCoL.Loader.Each``1(System.Int64,System.Func{System.Int64,``0})">
            <summary>
            Helper iterator to repeatedly call a function, like Enumerator.Range, but for Int64
            </summary>
            <param name="count">The number of repetitions to perform</param>
            <param name="op">The method to call, which receives the index</param>
            <typeparam name="T">The return type parameter.</typeparam>
        </member>
        <member name="M:CoCoL.Loader.StartFromTypes(System.Type[])">
            <summary>
            Starts all process found in the given types
            </summary>
            <returns>The number of processes started</returns>
            <param name="types">The types to examine</param>
        </member>
        <member name="M:CoCoL.Loader.StartFromTypes(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Starts all process found in the given types
            </summary>
            <returns>The number of processes started</returns>
            <param name="types">The types to examine</param>
        </member>
        <member name="M:CoCoL.Loader.StartFromProcesses(System.Collections.Generic.IEnumerable{CoCoL.IProcess})">
            <summary>
            Starts processes by scheduling their run method for execution
            </summary>
            <returns>The number of processes started</returns>
            <param name="processes">The list of process instances to start</param>
        </member>
        <member name="M:CoCoL.Loader.StartFromProcesses(System.Collections.Generic.IEnumerable{CoCoL.IAsyncProcess})">
            <summary>
            Starts processes by scheduling their run method for execution
            </summary>
            <returns>The number of processes started</returns>
            <param name="processes">The list of process instances to start</param>
        </member>
        <member name="M:CoCoL.Loader.StartAsync(System.Collections.Generic.IEnumerable{CoCoL.IProcess})">
            <summary>
            Starts processes by scheduling their run method for execution
            </summary>
            <returns>The number of processes started</returns>
            <param name="processes">The list of process instances to start</param>
        </member>
        <member name="M:CoCoL.Loader.StartAsync(System.Collections.Generic.IEnumerable{CoCoL.IAsyncProcess})">
            <summary>
            Starts processes by scheduling their run method for execution
            </summary>
            <returns>The number of processes started</returns>
            <param name="processes">The list of process instances to start</param>
        </member>
        <member name="M:CoCoL.Loader.Start(System.Collections.Generic.IEnumerable{CoCoL.IProcess})">
            <summary>
            Starts processes by scheduling their run method for execution
            </summary>
            <returns>The number of processes started</returns>
            <param name="processes">The list of process instances to start</param>
        </member>
        <member name="M:CoCoL.Loader.Start(System.Collections.Generic.IEnumerable{CoCoL.IAsyncProcess})">
            <summary>
            Starts processes by scheduling their run method for execution
            </summary>
            <returns>The number of processes started</returns>
            <param name="processes">The list of process instances to start</param>
        </member>
        <member name="T:CoCoL.ChannelScope">
            <summary>
            Implementation of a nested scope for assigning channel names
            </summary>
        </member>
        <member name="F:CoCoL.ChannelScope.Root">
            <summary>
            The root scope, where all other scopes descend from
            </summary>
        </member>
        <member name="F:CoCoL.ChannelScope.__lock">
            <summary>
            The lock object
            </summary>
        </member>
        <member name="F:CoCoL.ChannelScope.__scopes">
            <summary>
            Lookup table for scopes
            </summary>
        </member>
        <member name="M:CoCoL.ChannelScope.#cctor">
            <summary>
            Static initializer to control the creation order
            </summary>
        </member>
        <member name="F:CoCoL.ChannelScope.m_isDisposed">
            <summary>
            True if this instance is disposed, false otherwise
            </summary>
        </member>
        <member name="P:CoCoL.ChannelScope.ParentScope">
            <summary>
            The parent scope, or null if this is the root scope
            </summary>
            <value>The parent scope.</value>
        </member>
        <member name="P:CoCoL.ChannelScope.Isolated">
            <summary>
            Gets a value indicating whether this scope is isolated, meaning that it does not inherit from the parent scope.
            </summary>
            <value><c>true</c> if this instance isolated; otherwise, <c>false</c>.</value>
        </member>
        <member name="F:CoCoL.ChannelScope.m_instancekey">
            <summary>
            The key for this instance
            </summary>
        </member>
        <member name="F:CoCoL.ChannelScope.m_lookup">
            <summary>
            The local storage for channels
            </summary>
        </member>
        <member name="F:CoCoL.ChannelScope.LOGICAL_CONTEXT_KEY">
            <summary>
            The key used to assign the current scope into the current call-context
            </summary>
        </member>
        <member name="M:CoCoL.ChannelScope.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:CoCoL.ChannelScope"/> class that derives from the current scope.
            </summary>
        </member>
        <member name="M:CoCoL.ChannelScope.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:CoCoL.ChannelScope"/> class that derives from the current scope.
            </summary>
            <param name="isolated"><c>True</c> if this is an isolated scope, <c>false</c> otherwise</param>
        </member>
        <member name="M:CoCoL.ChannelScope.#ctor(CoCoL.ChannelScope,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:CoCoL.ChannelScope"/> class that derives from a parent scope.
            </summary>
            <param name="parent">The parent scope.</param>
            <param name="isolated"><c>True</c> if this is an isolated scope, <c>false</c> otherwise</param>
        </member>
        <member name="M:CoCoL.ChannelScope.GetOrCreate(CoCoL.ChannelNameAttribute,System.Type)">
            <summary>
            Gets or creates a channel
            </summary>
            <returns>The or create.</returns>
            <param name="attribute">The attribute describing the channel to create.</param>
            <param name="datatype">The type of data communicated through the channel.</param>
        </member>
        <member name="M:CoCoL.ChannelScope.GetOrCreate(System.String,System.Type,System.Int32,System.Int32,System.Int32,CoCoL.QueueOverflowStrategy,CoCoL.QueueOverflowStrategy,System.Boolean,System.Int32,System.Int32)">
            <summary>
            Gets or creates a channel
            </summary>
            <returns>The or create.</returns>
            <param name="name">The name of the channel to create.</param>
            <param name="datatype">The type of data communicated through the channel.</param>
            <param name="buffersize">The size of the channel buffer.</param>
            <param name="maxPendingReaders">The maximum number of pending readers. A negative value indicates infinite</param>
            <param name="maxPendingWriters">The maximum number of pending writers. A negative value indicates infinite</param>
            <param name="pendingReadersOverflowStrategy">The strategy for dealing with overflow for read requests</param>
            <param name="pendingWritersOverflowStrategy">The strategy for dealing with overflow for write requests</param>
            <param name="broadcast"><c>True</c> will create the channel as a broadcast channel, the default <c>false</c> will create a normal channel</param>
            <param name="initialBroadcastBarrier">The number of readers required on the channel before sending the first broadcast, can only be used with broadcast channels</param>
            <param name="broadcastMinimum">The minimum number of readers required on the channel, before a broadcast can be performed, can only be used with broadcast channels</param>
        </member>
        <member name="M:CoCoL.ChannelScope.GetOrCreate``1(CoCoL.ChannelNameMarker)">
            <summary>
            Gets or creates a channel
            </summary>
            <returns>The channel with the given name.</returns>
            <param name="marker">The <see cref="T:CoCoL.ChannelNameMarker"/> of the channel to create.</param>
            <typeparam name="T">The type of data in the channel.</typeparam>
        </member>
        <member name="M:CoCoL.ChannelScope.GetOrCreate``1(CoCoL.ChannelMarkerWrapper{``0})">
            <summary>
            Gets or creates a channel
            </summary>
            <returns>The channel with the given name.</returns>
            <param name="marker">The <see cref="T:CoCoL.ChannelNameMarker"/> of the channel to create.</param>
            <typeparam name="T">The type of data in the channel.</typeparam>
        </member>
        <member name="M:CoCoL.ChannelScope.GetOrCreate``1(CoCoL.ChannelNameAttribute)">
            <summary>
            Gets or creates a channel
            </summary>
            <returns>The channel with the given name.</returns>
            <param name="attribute">The attribute describing the channel.</param>
            <typeparam name="T">The type of data in the channel.</typeparam>
        </member>
        <member name="M:CoCoL.ChannelScope.GetOrCreate``1(System.String,System.Int32,System.Int32,System.Int32,CoCoL.QueueOverflowStrategy,CoCoL.QueueOverflowStrategy,System.Boolean,System.Int32,System.Int32)">
            <summary>
            Gets or creates a channel
            </summary>
            <returns>The channel with the given name.</returns>
            <param name="name">The name of the channel to create.</param>
            <param name="buffersize">The size of the channel buffer.</param>
            <param name="maxPendingReaders">The maximum number of pending readers. A negative value indicates infinite</param>
            <param name="maxPendingWriters">The maximum number of pending writers. A negative value indicates infinite</param>
            <param name="pendingReadersOverflowStrategy">The strategy for dealing with overflow for read requests</param>
            <param name="pendingWritersOverflowStrategy">The strategy for dealing with overflow for write requests</param>
            <param name="broadcast"><c>True</c> will create the channel as a broadcast channel, the default <c>false</c> will create a normal channel</param>
            <param name="initialBroadcastBarrier">The number of readers required on the channel before sending the first broadcast, can only be used with broadcast channels</param>
            <param name="broadcastMinimum">The minimum number of readers required on the channel, before a broadcast can be performed, can only be used with broadcast channels</param>
            <typeparam name="T">The type of data in the channel.</typeparam>
        </member>
        <member name="M:CoCoL.ChannelScope.DoCreateChannel``1(CoCoL.ChannelNameAttribute)">
            <summary>
            Creates the channel by calling the ChannelManager.
            </summary>
            <returns>The channel with the given name.</returns>
            <param name="attribute">The attribute describing the channel to create.</param>
            <typeparam name="T">The type of data in the channel.</typeparam>
        </member>
        <member name="M:CoCoL.ChannelScope.RecursiveLookup(System.String)">
            <summary>
            Performs a recursive lookup to find the specified channel.
            Returns null if no such channel was found
            </summary>
            <returns>The channel.</returns>
            <param name="name">The name to look for.</param>
        </member>
        <member name="M:CoCoL.ChannelScope.Dispose">
            <summary>
            Releases all resource used by the <see cref="T:CoCoL.ChannelScope"/> object.
            </summary>
            <remarks>Call <see cref="M:CoCoL.ChannelScope.Dispose"/> when you are finished using the <see cref="T:CoCoL.ChannelScope"/>. The
            <see cref="M:CoCoL.ChannelScope.Dispose"/> method leaves the <see cref="T:CoCoL.ChannelScope"/> in an unusable state. After calling
            <see cref="M:CoCoL.ChannelScope.Dispose"/>, you must release all references to the <see cref="T:CoCoL.ChannelScope"/> so the garbage
            collector can reclaim the memory that the <see cref="T:CoCoL.ChannelScope"/> was occupying.</remarks>
        </member>
        <member name="P:CoCoL.ChannelScope.Current">
            <summary>
            Gets the current channel scope.
            </summary>
            <value>The current scope.</value>
        </member>
        <member name="T:CoCoL.AutomationExtensions">
            <summary>
            Functionality for automatically wiring up channels
            </summary>
        </member>
        <member name="M:CoCoL.AutomationExtensions.AutoWireChannels``1(System.Collections.Generic.IEnumerable{``0},CoCoL.ChannelScope)">
            <summary>
            Wires up all named channels using the supplied scope
            </summary>
            <param name="items">The processes to wire up.</param>
            <param name="scope">The current scope.</param>
        </member>
        <member name="M:CoCoL.AutomationExtensions.AutoWireChannels(System.Collections.Generic.IEnumerable{CoCoL.IProcess},CoCoL.ChannelScope)">
            <summary>
            Wires up all named channels using the supplied scope
            </summary>
            <param name="items">The processes to wire up.</param>
            <param name="scope">The current scope.</param>
        </member>
        <member name="M:CoCoL.AutomationExtensions.AutoWireChannels(CoCoL.IProcess,CoCoL.ChannelScope)">
            <summary>
            Wires up all named channels using the supplied scope
            </summary>
            <param name="item">The item to wire up.</param>
            <param name="scope">The current scope.</param>
        </member>
        <member name="M:CoCoL.AutomationExtensions.AutoWireChannels``1(``0,CoCoL.ChannelScope)">
            <summary>
            Wires up all named channels using the supplied scope.
            Checks if the supplied item is an IEnumerable and iterates it
            if possible
            </summary>
            <param name="item">The item to wire up.</param>
            <param name="scope">The current scope.</param>
        </member>
        <member name="M:CoCoL.AutomationExtensions.AutoWireChannelsDirect``1(``0,CoCoL.ChannelScope)">
            <summary>
            Wires up all named channels using the supplied scope for the given element.
            Does not check if the given item is an IEnumerable
            </summary>
            <param name="item">The item to wire up.</param>
            <param name="scope">The current scope.</param>
        </member>
        <member name="M:CoCoL.AutomationExtensions.GetAllFieldAndPropertyValuesOfType``1(System.Object)">
            <summary>
            Gets all fields and properties with a type that is assignable to T
            </summary>
            <returns>All field and property values of type.</returns>
            <param name="item">The item to examine.</param>
            <typeparam name="T">The type of the items to return.</typeparam>
        </member>
        <member name="M:CoCoL.AutomationExtensions.RetireChannel(System.Object,System.Type)">
            <summary>
            Retires a channel
            </summary>
            <param name="value">The channel to retire.</param>
            <param name="definedtype">The type obtained from the declaring field.</param>
        </member>
        <member name="M:CoCoL.AutomationExtensions.RetireAllChannels(System.Object)">
            <summary>
            Uses reflection to find all properties and fields that are of type IRetireAbleChannel
            and calls the Retire method on them
            </summary>
            <param name="item">The instance to examine.</param>
        </member>
        <member name="M:CoCoL.AutomationExtensions.RunProtected(System.IDisposable,System.Func{System.Threading.Tasks.Task},System.Boolean)">
            <summary>
            Runs a method and disposes this instance afterwards
            </summary>
            <returns>The task for completion.</returns>
            <param name="instance">The instance to dispose after running</param>
            <param name="method">The callback method that does the actual work.</param>
            <param name="catchRetiredExceptions">If set to <c>true</c> any RetiredExceptions are caught and ignored.</param>
        </member>
        <member name="M:CoCoL.AutomationExtensions.RunTask``1(``0,System.Func{``0,System.Threading.Tasks.Task},System.Boolean)">
            <summary>
            Helper method for providing channels in an external object, 
            such that simple processes do not need to define a class instance
            </summary>
            <returns>The awaitable task for the process</returns>
            <param name="channels">The channel object to use. Accepts anonymous types.</param>
            <param name="method">The process method.</param>
            <typeparam name="T">The type of the channel object parameter.</typeparam>
            <param name="catchRetiredExceptions">If set to <c>true</c> any RetiredExceptions are caught and ignored.</param>
        </member>
        <member name="M:CoCoL.AutomationExtensions.IsRetiredException(System.Exception)">
            <summary>
            Determines if is the exception is a RetiredException.
            </summary>
            <returns><c>true</c> the exception is a RetiredException; otherwise, <c>false</c>.</returns>
            <param name="self">The exception to investigate.</param>
        </member>
        <member name="M:CoCoL.AutomationExtensions.IsTimeoutException(System.Exception)">
            <summary>
            Determines if is the exception is a TimeoutException.
            </summary>
            <returns><c>true</c> the exception is a TimeoutException; otherwise, <c>false</c>.</returns>
            <param name="self">The exception to investigate.</param>
        </member>
        <member name="T:CoCoL.ChannelEndBase">
            <summary>
            Base class for a channel end, that is a channel interface that is either read or write
            </summary>
        </member>
        <member name="F:CoCoL.ChannelEndBase.m_target">
            <summary>
            The read channel target
            </summary>
        </member>
        <member name="F:CoCoL.ChannelEndBase.m_hasLeft">
            <summary>
            <c>1</c> if leave has been called, <c>0</c> otherwise
            </summary>
        </member>
        <member name="F:CoCoL.ChannelEndBase.m_isReader">
            <summary>
            <c>true</c> if the request is a reader, <c>false</c> otherwise
            </summary>
        </member>
        <member name="M:CoCoL.ChannelEndBase.#ctor(CoCoL.IRetireAbleChannel,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:CoCoL.ChannelEndBase"/> class.
            </summary>
        </member>
        <member name="M:CoCoL.ChannelEndBase.Finalize">
            <summary>
            Releases unmanaged resources and performs other cleanup operations before the <see cref="T:CoCoL.ChannelEndBase"/>
            is reclaimed by garbage collection.
            </summary>
        </member>
        <member name="M:CoCoL.ChannelEndBase.Dispose(System.Boolean)">
            <summary>
            Releases all resource used by the <see cref="T:CoCoL.ChannelEndBase"/> object.
            </summary>
            <param name="disposing"><c>true</c> if disposing, <c>false</c> otherwise</param>
            <remarks>Call <see cref="M:CoCoL.ChannelEndBase.Dispose"/> when you are finished using the <see cref="T:CoCoL.ChannelEndBase"/>. The
            <see cref="M:CoCoL.ChannelEndBase.Dispose"/> method leaves the <see cref="T:CoCoL.ChannelEndBase"/> in an unusable state. After calling
            <see cref="M:CoCoL.ChannelEndBase.Dispose"/>, you must release all references to the <see cref="T:CoCoL.ChannelEndBase"/> so the garbage
            collector can reclaim the memory that the <see cref="T:CoCoL.ChannelEndBase"/> was occupying.</remarks>
        </member>
        <member name="M:CoCoL.ChannelEndBase.RetireAsync">
            <summary>
            Stops this channel from processing messages
            </summary>
        </member>
        <member name="M:CoCoL.ChannelEndBase.RetireAsync(System.Boolean)">
            <summary>
            Stops this channel from processing messages
            </summary>
            <param name="immediate">Retires the channel without processing the queue, which may cause lost messages</param>
        </member>
        <member name="P:CoCoL.ChannelEndBase.IsRetiredAsync">
            <summary>
            Gets a value indicating whether this instance is retired.
            </summary>
            <value><c>true</c> if this instance is retired; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:CoCoL.ChannelEndBase.JoinAsync">
            <summary>
            Join the channel
            </summary>
        </member>
        <member name="M:CoCoL.ChannelEndBase.LeaveAsync">
            <summary>
            Leave the channel.
            </summary>
        </member>
        <member name="M:CoCoL.ChannelEndBase.Dispose">
            <summary>
            Releases all resource used by the <see cref="T:CoCoL.ChannelEndBase"/> object.
            </summary>
            <remarks>Call <see cref="M:CoCoL.ChannelEndBase.Dispose"/> when you are finished using the <see cref="T:CoCoL.ChannelEndBase"/>. The
            <see cref="M:CoCoL.ChannelEndBase.Dispose"/> method leaves the <see cref="T:CoCoL.ChannelEndBase"/> in an unusable state. After calling
            <see cref="M:CoCoL.ChannelEndBase.Dispose"/>, you must release all references to the <see cref="T:CoCoL.ChannelEndBase"/> so the garbage
            collector can reclaim the memory that the <see cref="T:CoCoL.ChannelEndBase"/> was occupying.</remarks>
        </member>
        <member name="T:CoCoL.ChannelReadEnd`1">
            <summary>
            Wrapper class that prevents write access to a channel
            </summary>
        </member>
        <member name="M:CoCoL.ChannelReadEnd`1.#ctor(CoCoL.IReadChannel{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:CoCoL.ChannelReadEnd`1"/> class.
            </summary>
        </member>
        <member name="M:CoCoL.ChannelReadEnd`1.ReadAsync(CoCoL.ITwoPhaseOffer)">
            <summary>
            Registers a desire to read from the channel
            </summary>
            <param name="offer">A callback method for offering an item, use null to unconditionally accept</param>
            <returns>The async.</returns>
        </member>
        <member name="M:CoCoL.ChannelReadEnd`1.ReadAsync(System.TimeSpan,CoCoL.ITwoPhaseOffer)">
            <summary>
            Registers a desire to read from the channel
            </summary>
            <param name="offer">A callback method for offering an item, use null to unconditionally accept</param>
            <param name="timeout">The time to wait for the operation, use zero to return a timeout immediately if no items can be read. Use a
            negative span to wait forever.</param>
            <returns>The async.</returns>
        </member>
        <member name="T:CoCoL.ChannelWriteEnd`1">
            <summary>
            Wrapper class that prevents write access to a channel
            </summary>
        </member>
        <member name="M:CoCoL.ChannelWriteEnd`1.#ctor(CoCoL.IWriteChannel{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:CoCoL.ChannelWriteEnd`1"/> class.
            </summary>
        </member>
        <member name="M:CoCoL.ChannelWriteEnd`1.WriteAsync(`0,CoCoL.ITwoPhaseOffer)">
            <summary>
            Registers a desire to write to the channel
            </summary>
            <param name="offer">A callback method for offering an item, use null to unconditionally accept</param>
            <param name="value">The value to write to the channel.</param>
            <returns>The async.</returns>
        </member>
        <member name="M:CoCoL.ChannelWriteEnd`1.WriteAsync(`0,System.TimeSpan,CoCoL.ITwoPhaseOffer)">
            <summary>
            Registers a desire to write to the channel
            </summary>
            <param name="offer">A callback method for offering an item, use null to unconditionally accept</param>
            <param name="value">The value to write to the channel.</param>
            <param name="timeout">The time to wait for the operation, use zero to return a timeout immediately if no items can be read. Use a
            negative span to wait forever.</param>
            <returns>The async.</returns>
        </member>
        <member name="T:CoCoL.ChannelMarker">
            <summary>
            Static factory class for creating channel markers
            </summary>
        </member>
        <member name="M:CoCoL.ChannelMarker.ForRead``1(CoCoL.ChannelNameAttribute)">
            <summary>
            Creates a marker property for a read channel
            </summary>
            <returns>The marker instance.</returns>
            <param name="attribute">The attribute describing the channel.</param>
            <typeparam name="T">The type of data passed on the channel.</typeparam>
        </member>
        <member name="M:CoCoL.ChannelMarker.ForRead``1(System.String,System.Int32,CoCoL.ChannelNameScope,System.Int32,System.Int32,CoCoL.QueueOverflowStrategy,CoCoL.QueueOverflowStrategy,System.Boolean,System.Int32,System.Int32)">
            <summary>
            Creates a marker property for a read channel
            </summary>
            <returns>The marker instance.</returns>
            <param name="name">The name of the channel.</param>
            <param name="buffersize">The desired buffersize to use if the channel is created.</param>
            <param name="targetScope">The scope to create or locate the name in.</param>
            <typeparam name="T">The type of data passed on the channel.</typeparam>
            <param name="maxPendingReaders">The maximum number of pending readers. A negative value indicates infinite</param>
            <param name="maxPendingWriters">The maximum number of pending writers. A negative value indicates infinite</param>
            <param name="pendingReadersOverflowStrategy">The strategy for dealing with overflow for read requests</param>
            <param name="pendingWritersOverflowStrategy">The strategy for dealing with overflow for write requests</param>
            <param name="broadcast"><c>True</c> will create the channel as a broadcast channel, the default <c>false</c> will create a normal channel</param>
            <param name="initialBroadcastBarrier">The number of readers required on the channel before sending the first broadcast, can only be used with broadcast channels</param>
            <param name="broadcastMinimum">The minimum number of readers required on the channel, before a broadcast can be performed, can only be used with broadcast channels</param>
        </member>
        <member name="M:CoCoL.ChannelMarker.ForWrite``1(CoCoL.ChannelNameAttribute)">
            <summary>
            Creates a marker property for a write channel
            </summary>
            <returns>The marker instance.</returns>
            <param name="attribute">The attribute describing the channel.</param>
            <typeparam name="T">The type of data passed on the channel.</typeparam>
        </member>
        <member name="M:CoCoL.ChannelMarker.ForWrite``1(System.String,System.Int32,CoCoL.ChannelNameScope,System.Int32,System.Int32,CoCoL.QueueOverflowStrategy,CoCoL.QueueOverflowStrategy,System.Boolean,System.Int32,System.Int32)">
            <summary>
            Creates a marker property for a write channel
            </summary>
            <returns>The marker instance.</returns>
            <param name="name">The name of the channel.</param>
            <param name="buffersize">The desired buffersize to use if the channel is created.</param>
            <param name="targetScope">The scope to create or locate the name in.</param>
            <typeparam name="T">The type of data passed on the channel.</typeparam>
            <param name="maxPendingReaders">The maximum number of pending readers. A negative value indicates infinite</param>
            <param name="maxPendingWriters">The maximum number of pending writers. A negative value indicates infinite</param>
            <param name="pendingReadersOverflowStrategy">The strategy for dealing with overflow for read requests</param>
            <param name="pendingWritersOverflowStrategy">The strategy for dealing with overflow for write requests</param>
            <param name="broadcast"><c>True</c> will create the channel as a broadcast channel, the default <c>false</c> will create a normal channel</param>
            <param name="initialBroadcastBarrier">The number of readers required on the channel before sending the first broadcast, can only be used with broadcast channels</param>
            <param name="broadcastMinimum">The minimum number of readers required on the channel, before a broadcast can be performed, can only be used with broadcast channels</param>
        </member>
        <member name="T:CoCoL.ChannelMarkerWrapper`1">
            <summary>
            Helper class for creating typed-and-named markers
            </summary>
        </member>
        <member name="F:CoCoL.ChannelMarkerWrapper`1.ForWrite">
            <summary>
            Gets the channel as a write request
            </summary>
        </member>
        <member name="F:CoCoL.ChannelMarkerWrapper`1.ForRead">
            <summary>
            Gets the channel as a read request
            </summary>
        </member>
        <member name="P:CoCoL.ChannelMarkerWrapper`1.Attribute">
            <summary>
            The attribute representing this marker
            </summary>
        </member>
        <member name="P:CoCoL.ChannelMarkerWrapper`1.Name">
            <summary>
            Gets the name of the channel
            </summary>
        </member>
        <member name="P:CoCoL.ChannelMarkerWrapper`1.BufferSize">
            <summary>
            The buffer size for the channel
            </summary>
        </member>
        <member name="P:CoCoL.ChannelMarkerWrapper`1.TargetScope">
            <summary>
            The target channel scope
            </summary>
        </member>
        <member name="P:CoCoL.ChannelMarkerWrapper`1.MaxPendingReaders">
            <summary>
            The maximum number of pending readers
            </summary>
        </member>
        <member name="P:CoCoL.ChannelMarkerWrapper`1.MaxPendingWriters">
            <summary>
            The maximum number of pendinger writers
            </summary>
        </member>
        <member name="P:CoCoL.ChannelMarkerWrapper`1.PendingReadersOverflowStrategy">
            <summary>
            The strategy for selecting pending readers to discard on overflow
            </summary>
        </member>
        <member name="P:CoCoL.ChannelMarkerWrapper`1.PendingWritersOverflowStrategy">
            <summary>
            The strategy for selecting pending readers to discard on overflow
            </summary>
        </member>
        <member name="M:CoCoL.ChannelMarkerWrapper`1.#ctor(CoCoL.ChannelNameAttribute)">
            <summary>
            Initializes a new instance of the <see cref="T:CoCoL.ChannelMarkerWrapper`1"/> class.
            </summary>
            <param name="attribute">The attribute describing the channel.</param>
        </member>
        <member name="T:CoCoL.ChannelNameMarker">
            <summary>
            Marker class for specifying channel attributes in anonymous types
            </summary>
        </member>
        <member name="P:CoCoL.ChannelNameMarker.Attribute">
            <summary>
            Gets the attribute representation of the data.
            </summary>
        </member>
        <member name="M:CoCoL.ChannelNameMarker.#ctor(CoCoL.ChannelNameAttribute)">
            <summary>
            Initializes a new instance of the <see cref="T:CoCoL.ChannelNameMarker"/> class.
            </summary>
            <param name="attribute">The attribute describing the channel.</param>
        </member>
        <member name="P:CoCoL.ChannelNameMarker.Name">
            <summary>
            Gets the name.
            </summary>
            <value>The name.</value>
        </member>
        <member name="T:CoCoL.ReadMarker`1">
            <summary>
            Marker class for specifying channel attributes in anonymous types
            </summary>
        </member>
        <member name="M:CoCoL.ReadMarker`1.#ctor(CoCoL.ChannelNameAttribute)">
            <summary>
            Initializes a new instance of the <see cref="T:CoCoL.ReadMarker`1"/> class.
            </summary>
            <param name="attribute">The attribute describing the channel.</param>
        </member>
        <member name="M:CoCoL.ReadMarker`1.ReadAsync(CoCoL.ITwoPhaseOffer)">
            <summary>
            Registers a desire to read from the channel
            </summary>
            <param name="offer">A callback method for offering an item, use null to unconditionally accept</param>
            <returns>The async.</returns>
        </member>
        <member name="M:CoCoL.ReadMarker`1.ReadAsync(System.TimeSpan,CoCoL.ITwoPhaseOffer)">
            <summary>
            Registers a desire to read from the channel
            </summary>
            <param name="offer">A callback method for offering an item, use null to unconditionally accept</param>
            <param name="timeout">The time to wait for the operation, use zero to return a timeout immediately if no items can be read. Use a
            negative span to wait forever.</param>
            <returns>The async.</returns>
        </member>
        <member name="M:CoCoL.ReadMarker`1.RetireAsync">
            <summary>
            Stops this channel from processing messages
            </summary>
        </member>
        <member name="M:CoCoL.ReadMarker`1.RetireAsync(System.Boolean)">
            <summary>
            Stops this channel from processing messages
            </summary>
            <param name="immediate">Retires the channel without processing the queue, which may cause lost messages</param>
        </member>
        <member name="P:CoCoL.ReadMarker`1.IsRetiredAsync">
            <summary>
            Gets a value indicating whether this instance is retired.
            </summary>
            <value><c>true</c> if this instance is retired; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:CoCoL.WriteMarker`1.#ctor(CoCoL.ChannelNameAttribute)">
            <summary>
            Initializes a new instance of the <see cref="T:CoCoL.WriteMarker`1"/> class.
            </summary>
            <param name="attribute">The attribute describing the channel.</param>
        </member>
        <member name="M:CoCoL.WriteMarker`1.WriteAsync(`0,CoCoL.ITwoPhaseOffer)">
            <summary>
            Registers a desire to write to the channel
            </summary>
            <param name="offer">A callback method for offering an item, use null to unconditionally accept</param>
            <param name="value">The value to write to the channel.</param>
            <returns>The async.</returns>
        </member>
        <member name="M:CoCoL.WriteMarker`1.WriteAsync(`0,System.TimeSpan,CoCoL.ITwoPhaseOffer)">
            <summary>
            Registers a desire to write to the channel
            </summary>
            <param name="offer">A callback method for offering an item, use null to unconditionally accept</param>
            <param name="value">The value to write to the channel.</param>
            <param name="timeout">The time to wait for the operation, use zero to return a timeout immediately if no items can be read. Use a
            negative span to wait forever.</param>
            <returns>The async.</returns>
        </member>
        <member name="M:CoCoL.WriteMarker`1.RetireAsync">
            <summary>
            Stops this channel from processing messages
            </summary>
        </member>
        <member name="M:CoCoL.WriteMarker`1.RetireAsync(System.Boolean)">
            <summary>
            Stops this channel from processing messages
            </summary>
            <param name="immediate">Retires the channel without processing the queue, which may cause lost messages</param>
        </member>
        <member name="P:CoCoL.WriteMarker`1.IsRetiredAsync">
            <summary>
            Gets a value indicating whether this instance is retired.
            </summary>
            <value><c>true</c> if this instance is retired; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:CoCoL.IsolatedChannelScope">
            <summary>
            A scope that does not inherit channels from its parent scope
            </summary>
        </member>
        <member name="M:CoCoL.IsolatedChannelScope.#ctor">
            <summary>
            Constructs a new isolated channel scope
            </summary>
        </member>
        <member name="M:CoCoL.IsolatedChannelScope.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Constructs a new isolated channel scope
            </summary>
            <param name="inheritedChannelNames">List of channels to inherit from the parent scope.</param>
        </member>
        <member name="M:CoCoL.IsolatedChannelScope.#ctor(System.String[])">
            <summary>
            Constructs a new isolated channel scope
            </summary>
            <param name="inheritedChannelNames">List of channels to inherit from the parent scope.</param>
        </member>
        <member name="M:CoCoL.IsolatedChannelScope.#ctor(System.Collections.Generic.IEnumerable{CoCoL.INamedItem})">
            <summary>
            Constructs a new isolated channel scope
            </summary>
            <param name="inheritedChannelNames">List of channels to inherit from the parent scope.</param>
        </member>
        <member name="M:CoCoL.IsolatedChannelScope.#ctor(CoCoL.INamedItem[])">
            <summary>
            Constructs a new isolated channel scope
            </summary>
            <param name="inheritedChannelNames">List of channels to inherit from the parent scope.</param>
        </member>
        <member name="M:CoCoL.IsolatedChannelScope.SetupInheritedChannels(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Adds all inherited channels to the current scope,
            and disposes this instance if an exception is thrown
            </summary>
            <param name="names">List of channels to inherit from the parent scope.</param>
        </member>
        <member name="M:CoCoL.IsolatedChannelScope.InjectChannel(System.String,CoCoL.IRetireAbleChannel)">
            <summary>
            Injects a channel into the current scope.
            </summary>
            <param name="name">The name of the channel to create.</param>
            <param name="channel">The channel to inject.</param>
        </member>
        <member name="M:CoCoL.IsolatedChannelScope.InjectChannelsFromParent(System.Collections.Generic.IEnumerable{System.String},CoCoL.ChannelScope)">
            <summary>
            Injects a channel into the current scope, by looking in the parent scope.
            This is particularly useful in isolated scopes, to selectively forward channels
            </summary>
            <param name="names">The names of the channel to create.</param>
            <param name="parent">The scope to look in, <code>null</code> means the current parent</param>
        </member>
        <member name="M:CoCoL.IsolatedChannelScope.InjectChannelsFromParent(System.String[])">
            <summary>
            Injects a channel into the current scope, by looking in the parent scope.
            This is particularly useful in isolated scopes, to selectively forward channels
            </summary>
            <param name="names">The name of the channel to create.</param>
        </member>
        <member name="M:CoCoL.IsolatedChannelScope.InjectChannelFromParent(System.String,CoCoL.ChannelScope)">
            <summary>
            Injects a channel into the current scope, by looking in the parent scope.
            This is particularly useful in isolated scopes, to selectively forward channels
            </summary>
            <param name="name">The name of the channel to create.</param>
            <param name="parent">The scope to look in, <code>null</code> means the current parent</param>
        </member>
        <member name="T:CoCoL.ExecutionScope">
            <summary>
            A scope that defines how to execute tasks that await a channel
            </summary>
        </member>
        <member name="F:CoCoL.ExecutionScope.Root">
            <summary>
            The root scope, where all other scopes descend from
            </summary>
        </member>
        <member name="F:CoCoL.ExecutionScope.__lock">
            <summary>
            The lock object
            </summary>
        </member>
        <member name="F:CoCoL.ExecutionScope.__scopes">
            <summary>
            Lookup table for scopes
            </summary>
        </member>
        <member name="F:CoCoL.ExecutionScope.LOGICAL_CONTEXT_KEY">
            <summary>
            The key used to assign the current scope into the current call-context
            </summary>
        </member>
        <member name="F:CoCoL.ExecutionScope.m_threadPool">
            <summary>
            The thread pool used to execute requests
            </summary>
        </member>
        <member name="F:CoCoL.ExecutionScope.m_isDisposed">
            <summary>
            True if this instance is disposed, false otherwise
            </summary>
        </member>
        <member name="F:CoCoL.ExecutionScope.m_instancekey">
            <summary>
            The key for this instance
            </summary>
        </member>
        <member name="P:CoCoL.ExecutionScope.ParentScope">
            <summary>
            The parent scope, or null if this is the root scope
            </summary>
            <value>The parent scope.</value>
        </member>
        <member name="M:CoCoL.ExecutionScope.#cctor">
            <summary>
            Static initializer to control the creation order
            </summary>
        </member>
        <member name="M:CoCoL.ExecutionScope.#ctor(CoCoL.IThreadPool)">
            <summary>
            Initializes a new instance of the <see cref="T:CoCoL.ExecutionScope"/> class.
            </summary>
            <param name="threadPool">The thread pool to use.</param>
        </member>
        <member name="M:CoCoL.ExecutionScope.#ctor(CoCoL.ExecutionScope,CoCoL.IThreadPool)">
            <summary>
            Initializes a new instance of the <see cref="T:CoCoL.ExecutionScope"/> class.
            </summary>
            <param name="parent">The parent scope.</param>
            <param name="threadPool">The thread pool implementation.</param>
        </member>
        <member name="M:CoCoL.ExecutionScope.QueueItem(System.Action)">
            <summary>
            Puts an item into the work queue
            </summary>
            <param name="a">The work item.</param>
        </member>
        <member name="M:CoCoL.ExecutionScope.QueueItem(System.Action{System.Object},System.Object)">
            <summary>
            Puts an item into the work queue
            </summary>
            <param name="a">The work item.</param>
            <param name="item">An optional callback parameter.</param>
        </member>
        <member name="M:CoCoL.ExecutionScope.QueueTask(System.Action)">
            <summary>
            Puts an item into the work queue
            </summary>
            <param name="a">The work item.</param>
            <returns>The awaitable task.</returns>
        </member>
        <member name="M:CoCoL.ExecutionScope.EnsureFinishedAsync(System.TimeSpan)">
            <summary>
            Ensures that the threadpool is finished or throws an exception.
            If the underlying threadpool does not support finishing, this call does nothing
            </summary>
            <param name="waittime">The maximum time to wait for completion.</param>
        </member>
        <member name="M:CoCoL.ExecutionScope.Dispose">
            <summary>
            Releases all resource used by the <see cref="T:CoCoL.ChannelScope"/> object.
            </summary>
            <remarks>Call <see cref="M:CoCoL.ExecutionScope.Dispose"/> when you are finished using the <see cref="T:CoCoL.ChannelScope"/>. The
            <see cref="M:CoCoL.ExecutionScope.Dispose"/> method leaves the <see cref="T:CoCoL.ChannelScope"/> in an unusable state. After calling
            <see cref="M:CoCoL.ExecutionScope.Dispose"/>, you must release all references to the <see cref="T:CoCoL.ChannelScope"/> so the garbage
            collector can reclaim the memory that the <see cref="T:CoCoL.ChannelScope"/> was occupying.</remarks>
        </member>
        <member name="P:CoCoL.ExecutionScope.Current">
            <summary>
            Gets the current execution scope.
            </summary>
            <value>The current scope.</value>
        </member>
        <member name="T:CoCoL.AsyncSemaphore">
            <summary>
            Implementation of a Semaphore that is usable with await statements
            </summary>
        </member>
        <member name="F:CoCoL.AsyncSemaphore.s_completed">
            <summary>
            A task signaling completion
            </summary>
        </member>
        <member name="F:CoCoL.AsyncSemaphore.m_waiters">
            <summary>
            The list of waiters
            </summary>
        </member>
        <member name="F:CoCoL.AsyncSemaphore.m_currentCount">
            <summary>
            The additional number of release calls
            </summary>
        </member>
        <member name="M:CoCoL.AsyncSemaphore.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:CoCoL.AsyncSemaphore"/> class.
            </summary>
            <param name="initialCount">The number of callers to allow before blocking.</param>
        </member>
        <member name="M:CoCoL.AsyncSemaphore.WaitAsync">
            <summary>
            Waits for the semaphire to be released
            </summary>
            <returns>The awaitable task.</returns>
        </member>
        <member name="M:CoCoL.AsyncSemaphore.Release">
            <summary>
            Releases the semaphore to a new 
            </summary>
        </member>
        <member name="T:CoCoL.AsyncLock">
            <summary>
            Implementation of a lock construct that can be used with await statements,
            note that this lock is not re-entrant like the regular monitors used
            with the lock statement.
            </summary>
        </member>
        <member name="F:CoCoL.AsyncLock.m_semaphore">
            <summary>
            The semaphore that provides the general functionality of this lock
            </summary>
        </member>
        <member name="F:CoCoL.AsyncLock.m_releaser">
            <summary>
            The task used to encapsulate the lock
            </summary>
        </member>
        <member name="M:CoCoL.AsyncLock.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:CoCoL.AsyncLock"/> class.
            </summary>
        </member>
        <member name="M:CoCoL.AsyncLock.LockAsync">
            <summary>
            Aquires the exclusive lock, and awaits until it is available
            </summary>
            <returns>The async.</returns>
        </member>
        <member name="T:CoCoL.AsyncLock.Releaser">
            <summary>
            Internal releaser construct which needs to be disposed to unlock
            </summary>
        </member>
        <member name="F:CoCoL.AsyncLock.Releaser.m_parent">
            <summary>
            The parent instance
            </summary>
        </member>
        <member name="F:CoCoL.AsyncLock.Releaser.m_canDispose">
            <summary>
            A value indicating if the lock can be disposed
            </summary>
        </member>
        <member name="M:CoCoL.AsyncLock.Releaser.#ctor(CoCoL.AsyncLock)">
            <summary>
            Initializes a new instance of the <see cref="T:CoCoL.AsyncLock.Releaser"/> struct.
            </summary>
            <param name="parent">The parent lock.</param>
        </member>
        <member name="M:CoCoL.AsyncLock.Releaser.Dispose">
            <summary>
            Releases all resource used by the <see cref="T:CoCoL.AsyncLock.Releaser"/> object.
            </summary>
            <remarks>Call <see cref="M:CoCoL.AsyncLock.Releaser.Dispose"/> when you are finished using the <see cref="T:CoCoL.AsyncLock.Releaser"/>. The
            <see cref="M:CoCoL.AsyncLock.Releaser.Dispose"/> method leaves the <see cref="T:CoCoL.AsyncLock.Releaser"/> in an unusable state. After
            calling <see cref="M:CoCoL.AsyncLock.Releaser.Dispose"/>, you must release all references to the <see cref="T:CoCoL.AsyncLock.Releaser"/> so
            the garbage collector can reclaim the memory that the <see cref="T:CoCoL.AsyncLock.Releaser"/> was occupying.</remarks>
        </member>
        <member name="T:CoCoL.BroadcastingChannel`1">
            <summary>
            Implements a broadcasting channel
            </summary>
        </member>
        <member name="F:CoCoL.BroadcastingChannel`1.m_minimumReaders">
            <summary>
            The minimum number of readers required for a broadcast to be performed
            </summary>
        </member>
        <member name="F:CoCoL.BroadcastingChannel`1.m_initialBarrierSize">
            <summary>
            The minimum number of readers required for the first broadcast to be performed
            </summary>
        </member>
        <member name="M:CoCoL.BroadcastingChannel`1.#ctor(CoCoL.ChannelNameAttribute)">
            <summary>
            Initializes a new instance of the <see cref="T:CoCoL.BroadcastingChannel&lt;1&gt;"/> class.
            </summary>
            <param name="attr">The channel name attributes.</param>
        </member>
        <member name="M:CoCoL.BroadcastingChannel`1.MatchReadersAndWriters(System.Boolean,System.Threading.Tasks.Task)">
            <summary>
            Method that examines the queues and matches readers with writers
            </summary>
            <returns>An awaitable that signals if the caller has been accepted or rejected.</returns>
            <param name="asReader"><c>True</c> if the caller method is a reader, <c>false</c> otherwise.</param>
            <param name="caller">The caller task.</param>
        </member>
        <member name="M:CoCoL.BroadcastingChannel`1.LeaveAsync(System.Boolean)">
            <summary>
            Leave the channel.
            </summary>
            <param name="asReader"><c>true</c> if leaving as a reader, <c>false</c> otherwise</param>
        </member>
        <member name="P:CoCoL.BroadcastingChannel`1.MinimumReaders">
            <summary>
            Gets the minimum number of readers allowed before a broadcast can be performed.
            </summary>
            <value>The minimum number of readers.</value>
        </member>
        <member name="M:CoCoL.BroadcastingChannel`1.SetMinimumReadersAsync(System.Int32)">
            <summary>
            Sets the minimum number of readers required before a broadcast can be performed.
            </summary>
            <returns>The awaitable task.</returns>
            <param name="value">The minimum number of readers.</param>
        </member>
        <member name="P:CoCoL.BroadcastingChannel`1.NextBarrierCount">
            <summary>
            Gets the number of processes required before the next broadcast is performed
            </summary>
        </member>
        <member name="M:CoCoL.BroadcastingChannel`1.SetNextBarrierCountAsync(System.Int32)">
            <summary>
            Sets the number of processes required before the next broadcast is performed
            </summary>
            <returns>The awaitable task.</returns>
            <param name="value">The minimum number of processes reqquired before the next broadcast.</param>
        </member>
    </members>
</doc>
